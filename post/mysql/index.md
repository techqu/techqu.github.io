
MYSQL实战45讲-极客时间笔记

<!--more-->


## 基础架构：一条SQL查询语句是如何执行的

### mysql架构组成

MySQL的逻辑架构图

![mysql-framework](/img/mysql-framework.png)

 - server端
    - 连接器：管理连接、权限验证
    - 分析器：词法分析、语法分析
    - 优化器：执行计划生成、索引选择
    - 执行器：操作引擎、返回结果
 - 存储引擎：存储数据，提供读写接口




## 日志系统：一条SQL更新语句是如何执行的

### InnodDB redo log 

 - WAL技术：Write-Ahead Logging，先写日志，再写磁盘
 - 当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里，并更新内存。其它合适时间再写入磁盘

### MYSQL binlog（归档日志）

### 不同点

 - redo log是InnoDB引擎特有的，binlog是MYSQL的Server层实现的，所有引擎都能用
 - redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑。
 - redo log是循环写的，空间固定会用完；binlog是可以追加写入的，写到一定大小会切换到下一个文件，不会覆盖以前的日志。

### redolog两阶段提交

 - 简单说，redo log 和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。
 
## 事务隔离：为什么你改了我还看不见

 - ACID
 - 可能出现的问题：脏读、不可重复读、幻读

### SQL标准的事务隔离级别

 - 读未提交
 - 读已提交
 - 可重复读
 - 串行化

### 事务隔离的实现
### 事务的启动方式
## 深入浅出索引(上)
### 索引的常见类型
### InnoDB的索引类型
### 索引维护
## 深入浅出索引(下)

- 回到主键索引树搜索的过程，称为回表

### 覆盖索引

- 由于覆盖索引可以减少书的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段

### 最左前缀原则

 - 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往需要优先考虑采用的。

### 索引下推

- mysql5.6之后引入索引下推优化（index condition pushdown），可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤调不满足条件的记录，减少回表次数

## 全局锁和表锁

### 全局锁的典型使用场景是，做全库逻辑备份

### 表级锁

 1. 表锁 lock tables ... read/write ,一般不使用
 2. 元数据锁（meta data lock，MDL）MYSQL5.5引入MDL
    -  当对一个表做增删改查操作的时候，加MDL读锁；
    -  当要对表做结构变更操作的时候，加MDL写锁；

## 行锁
- 两阶段锁协议
- 死锁和死锁检测

## 事务到底是隔离的还是不隔离的

 - “快照”在MVCC里是怎么工作的
 - InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力

## 普通索引和唯一索引，应该如何选择

- 从普通索引和唯一索引的选择开始，分享了数据的查询和更新过程，然后说明了change buffer的机制以及应用场景，最后讲到了索引选择的实践。
- 由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发，建议优先考虑非唯一索引。




## in和OR对比的结论：

1.in或or在字段有添加索引的情况下，查询很快，两者查询速度没有什么区别；

2.in或or在字段没有添加索引的情况下,所连接的字段越多(1or2or3or4or......)，or比in的查询效率低很多