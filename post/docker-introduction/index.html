<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Docker的实现原理 - Quguang 学习笔记</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="瞿广" /><meta name="description" content="容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”
Docker容器具有以下3个特点：
 轻量级：在同一台宿主机上的容器共享系统Kernel，这使得他们可以迅速启动而且占有的内存极少。镜像是以分层文件系统构造的，这可以让它们共享相同的文件，使得磁盘使用率和镜像下载速度得到提高。 开放：Docker容器基于开放标准，这使得Docker容器可以运行在主流Linux发行版和Windows操作系统上。 安全：容器将各个应用程序隔离开来，这给所有的应用程序提供了一层额外的安全防护。  对于Docker等大多数Linux容器来说，Cgroups技术是用来制造约束的主要手段，而Namespace技术则是用来修改进程视图的主要方法。
" /><meta name="keywords" content="Docker的实现原理, 容器, Docker" />






<meta name="generator" content="Hugo 0.52 with even 4.0.0" />


<link rel="canonical" href="https://techqu.github.io/post/docker-introduction/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/douban.css">
<link rel="stylesheet" href="/css/techqu.css">


<meta property="og:title" content="Docker的实现原理" />
<meta property="og:description" content="容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”

Docker容器具有以下3个特点：


轻量级：在同一台宿主机上的容器共享系统Kernel，这使得他们可以迅速启动而且占有的内存极少。镜像是以分层文件系统构造的，这可以让它们共享相同的文件，使得磁盘使用率和镜像下载速度得到提高。
开放：Docker容器基于开放标准，这使得Docker容器可以运行在主流Linux发行版和Windows操作系统上。
安全：容器将各个应用程序隔离开来，这给所有的应用程序提供了一层额外的安全防护。


对于Docker等大多数Linux容器来说，Cgroups技术是用来制造约束的主要手段，而Namespace技术则是用来修改进程视图的主要方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://techqu.github.io/post/docker-introduction/" /><meta property="article:published_time" content="2019-01-17T15:12:03&#43;08:00"/>
<meta property="article:modified_time" content="2019-01-18T15:12:03&#43;08:00"/>

<meta itemprop="name" content="Docker的实现原理">
<meta itemprop="description" content="容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”

Docker容器具有以下3个特点：


轻量级：在同一台宿主机上的容器共享系统Kernel，这使得他们可以迅速启动而且占有的内存极少。镜像是以分层文件系统构造的，这可以让它们共享相同的文件，使得磁盘使用率和镜像下载速度得到提高。
开放：Docker容器基于开放标准，这使得Docker容器可以运行在主流Linux发行版和Windows操作系统上。
安全：容器将各个应用程序隔离开来，这给所有的应用程序提供了一层额外的安全防护。


对于Docker等大多数Linux容器来说，Cgroups技术是用来制造约束的主要手段，而Namespace技术则是用来修改进程视图的主要方法。">


<meta itemprop="datePublished" content="2019-01-17T15:12:03&#43;08:00" />
<meta itemprop="dateModified" content="2019-01-18T15:12:03&#43;08:00" />
<meta itemprop="wordCount" content="4545">



<meta itemprop="keywords" content="docker,容器," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Docker的实现原理"/>
<meta name="twitter:description" content="容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”

Docker容器具有以下3个特点：


轻量级：在同一台宿主机上的容器共享系统Kernel，这使得他们可以迅速启动而且占有的内存极少。镜像是以分层文件系统构造的，这可以让它们共享相同的文件，使得磁盘使用率和镜像下载速度得到提高。
开放：Docker容器基于开放标准，这使得Docker容器可以运行在主流Linux发行版和Windows操作系统上。
安全：容器将各个应用程序隔离开来，这给所有的应用程序提供了一层额外的安全防护。


对于Docker等大多数Linux容器来说，Cgroups技术是用来制造约束的主要手段，而Namespace技术则是用来修改进程视图的主要方法。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">miao</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">miao</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Docker的实现原理</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-01-17 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E7%AC%94%E8%AE%B0/"> 极客时间笔记 </a>
            <a href="/categories/%E5%AE%B9%E5%99%A8/"> 容器 </a>
            </div>
          <span class="more-meta"> 约 4545 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#一-linux-namespace的隔离能力">一、Linux Namespace的隔离能力</a></li>
<li><a href="#二-linux-cgroup的限制能力">二、Linux Cgroup的限制能力</a></li>
<li><a href="#三-rootfs的文件系统">三、rootfs的文件系统</a></li>
<li><a href="#四-从rootfs文件系统到容器镜像">四、从rootfs文件系统到容器镜像</a></li>
<li><a href="#参考书目">参考书目</a></li>
<li><a href="#参考文章">参考文章</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”</p>

<p>Docker容器具有以下3个特点：</p>

<ul>
<li><strong>轻量级</strong>：在同一台宿主机上的容器共享系统Kernel，这使得他们可以迅速启动而且占有的内存极少。镜像是以分层文件系统构造的，这可以让它们共享相同的文件，使得磁盘使用率和镜像下载速度得到提高。</li>
<li><strong>开放</strong>：Docker容器基于开放标准，这使得Docker容器可以运行在主流Linux发行版和Windows操作系统上。</li>
<li><strong>安全</strong>：容器将各个应用程序隔离开来，这给所有的应用程序提供了一层额外的安全防护。</li>
</ul>

<p>对于Docker等大多数Linux容器来说，<strong>Cgroups技术是用来制造约束的主要手段，而Namespace技术则是用来修改进程视图的主要方法。</strong></p>

<h2 id="一-linux-namespace的隔离能力">一、Linux Namespace的隔离能力</h2>

<p>假设你已经有了一个 Linux 操作系统上的 Docker 项目在运行，比如我的环境是 Ubuntu 16.04 和 Docker CE 18.05。</p>

<p>接下来，让我们首先创建一个容器来试试。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run -it busybox /bin/sh</code></pre></td></tr></table>
</div>
</div>
<p>这样，我的 Ubuntu 16.04 机器就变成了一个宿主机，而一个运行着 /bin/sh 的容器，就跑在了这个宿主机里面。</p>

<p>上面的例子和原理，如果你已经玩过 Docker，一定不会感到陌生。此时，如果我们在容器里执行一下 ps 指令，就会发现一些更有趣的事情：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">/ <span class="c1"># ps</span>
PID  USER   TIME COMMAND
  <span class="m">1</span> root   <span class="m">0</span>:00 /bin/sh
  <span class="m">10</span> root   <span class="m">0</span>:00 ps</code></pre></td></tr></table>
</div>
</div>
<p>可以看到，我们在 Docker 里最开始执行的 /bin/sh ，就是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有两个进程在运行。这就意味着，前面执行的 /bin/sh，以及我们刚刚执行的 ps，已经被 Docker 隔离在了一个跟宿主机完全不同的世界当中。</p>

<p><strong>这种技术，就是 Linux 里面的 Namespace 机制</strong>。而 Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 <code>clone()</code>，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">int pid = clone(main_function, stack_size, SIGCHLD, NULL); </pre></td></tr></table>
</div>
</div>
<p>这个系统调用就会为我们创建一个新的进程，并且返回它的进程号pid。</p>

<p>而当我们用clone（）系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); </pre></td></tr></table>
</div>
</div>
<p>这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。</p>

<p>当然，我们还可以多次执行上面的 clone() 调用，这样就会创建多个 PID Namespace，而每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况。</p>

<p><strong>除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。</strong></p>

<table>
<thead>
<tr>
<th>namespace</th>
<th>引入的相关内核版本</th>
<th>被隔离的全局系统资源</th>
<th>在容器语境下的隔离效果</th>
</tr>
</thead>

<tbody>
<tr>
<td>Mount namespaces</td>
<td>Linux 2.4.19</td>
<td>文件系统挂接点</td>
<td>每个容器能看到不同的文件系统层次结构</td>
</tr>

<tr>
<td>UTS namespaces</td>
<td>Linux 2.6.19</td>
<td>nodename 和 domainname</td>
<td>每个容器可以有自己的 hostname 和 domainame</td>
</tr>

<tr>
<td>IPC namespaces</td>
<td>Linux 2.6.19</td>
<td>特定的进程间通信资源，包括System V IPC 和  POSIX message queues</td>
<td>每个容器有其自己的 System V IPC 和 POSIX 消息队列文件系统，因此，只有在同一个 IPC</td>
</tr>

<tr>
<td>PID namespaces</td>
<td>Linux 2.6.24</td>
<td>进程 ID 数字空间 （process ID number space）</td>
<td>每个 PID namespace 中的进程可以有其独立的 PID； 每个容器可以有其 PID 为 1 的root 进程；也使得容器可以在不同的 host 之间迁移，因为 namespace 中的进程 ID 和 host 无关了。这也使得容器中的每个进程有两个PID：容器中的 PID 和 host 上的 PID。</td>
</tr>

<tr>
<td>Network namespaces</td>
<td>始于Linux 2.6.24 完成于 Linux 2.6.29</td>
<td>网络相关的系统资源</td>
<td>每个容器用有其独立的网络设备，IP 地址，IP 路由表，/proc/net 目录，端口号等等。这也使得一个 host 上多个容器内的同一个应用都绑定到各自容器的 80 端口上。</td>
</tr>

<tr>
<td>User namespaces</td>
<td>始于 Linux 2.6.23 完成于 Linux 3.8)</td>
<td>用户和组 ID 空间</td>
<td>在 user namespace 中的进程的用户和组 ID 可以和在 host 上不同； 每个 container 可以有不同的 user 和 group id；一个 host 上的非特权用户可以成为 user namespace 中的特权用户；</td>
</tr>
</tbody>
</table>

<p>比如，Mount Namespace ，用于让被隔离进程只看到当前 Namespace 里的挂载点信息； Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。</p>

<p><strong>这，就是 Linux 容器最基本的实现原理了。</strong></p>

<p>在理解了 Namespace 的工作方式之后，你就会明白，跟真实存在的虚拟机不同，在使用 Docker 的时候，并没有一个真正的“Docker 容器”运行在宿主机里面。Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时，Docker 为它们加上了各种各样的 Namespace 参数。</p>

<div class="admonition note"><p class="admonition-title">note</p>
  <p>所以，Docker 容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，<strong>指定了这个进程所需要启用的一组 Namespace 参数</strong>。<strong>这样，容器就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。</strong>而对于宿主机以及其他不相关的程序，它就完全看不到了。</p>

<p><strong>所以说，容器，其实是一种特殊的进程而已。</strong></p>

</div>

<h2 id="二-linux-cgroup的限制能力">二、Linux Cgroup的限制能力</h2>

<p>一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制。</p>

<p><strong>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。</strong>通过Cgroup，可以方便地限制某个进程的资源占用，并且可以实时地监控进程的监控和统计信息。</p>

<p><strong>Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合</strong>
。而对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。</p>

<p>而至于在这些控制组下面的资源文件里填上什么值，就靠用户执行 docker run 时的参数指定了，比如这样一条命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ docker run -it --cpu-period<span class="o">=</span><span class="m">100000</span> --cpu-quota<span class="o">=</span><span class="m">20000</span> ubuntu /bin/bash</code></pre></td></tr></table>
</div>
</div>
<p>在启动这个容器后，我们可以通过查看 Cgroups 文件系统下，CPU 子系统中，“docker”这个控制组里的资源限制文件的内容来确认：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us 
<span class="m">100000</span>
$ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us 
<span class="m">20000</span></code></pre></td></tr></table>
</div>
</div>
<p>这就意味着这个 Docker 容器，只能使用到 20% 的 CPU 带宽。</p>

<h2 id="三-rootfs的文件系统">三、rootfs的文件系统</h2>

<p>容器里的进程看到的文件系统又是什么样子的呢？</p>

<blockquote>
<p>其实，即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样。</p>
</blockquote>

<p>Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知。但是，这也就意味着，只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。</p>

<p>这时，你可能已经想到了一个解决办法：创建新进程时，除了声明要启用 Mount Namespace 之外，我们还可以告诉容器进程，有哪些目录需要重新挂载，就比如这个 /tmp 目录。于是，我们在容器进程执行前可以添加一步重新挂载 /tmp 目录的操作：</p>

<p><strong>这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。</strong></p>

<p>不难想到，我们可以在容器进程启动之前重新挂载它的整个根目录“/”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。</p>

<p>在 Linux 操作系统里，有一个名为 chroot 的命令可以帮助你在 shell 中方便地完成这个工作。顾名思义，它的作用就是帮你“change root file system”，即改变进程的根目录到你指定的位置。它的用法也非常简单。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1">#执行 chroot 命令，告诉操作系统，我们将使用 $HOME/test 目录作为 /bin/bash 进程的根目录：</span>
$ chroot <span class="nv">$HOME</span>/test /bin/bash</code></pre></td></tr></table>
</div>
</div>
<p>而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。</p>

<p>所以，一个最常见的 rootfs，或者说容器镜像，会包括如下所示的一些目录和文件，比如 /bin，/etc，/proc 等等：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ ls /
bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var</code></pre></td></tr></table>
</div>
</div>
<p>而你进入容器之后执行的 /bin/bash，就是 /bin 目录下的可执行文件，与宿主机的 /bin/bash 完全不同。</p>

<p><strong>现在，你应该可以理解，对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：</strong></p>

<ol>
<li><strong>启用 Linux Namespace 配置；</strong></li>
<li><strong>设置指定的 Cgroups 参数；</strong></li>
<li><strong>切换进程的根目录（Change Root）。</strong></li>
</ol>

<p>这样，一个完整的容器就诞生了。不过，Docker 项目在最后一步的切换上会优先使用 pivot_root 系统调用，如果系统不支持，才会使用 chroot。这两个系统调用虽然功能类似，但是也有细微的区别</p>

<p>由于云端与本地服务器环境不同，应用的打包过程，一直是使用 PaaS 时最“痛苦”的一个步骤。但有了容器之后，更准确地说，有了容器镜像（即 rootfs）之后，这个问题被非常优雅地解决了。</p>

<p>由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。</p>

<p>事实上，对于大多数开发者而言，他们对应用依赖的理解，一直局限在编程语言层面。比如 Golang 的 Godeps.json。但实际上，一个一直以来很容易被忽视的事实是，<strong>对一个应用来说，操作系统本身才是它运行所需要的最完整的“依赖库”。</strong></p>

<p><strong>这种深入到操作系统级别的运行环境一致性，打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟。</strong></p>

<h2 id="四-从rootfs文件系统到容器镜像">四、从rootfs文件系统到容器镜像</h2>

<p>不过，这时你可能已经发现了另一个非常棘手的问题：难道我每开发一个应用，或者升级一下现有的应用，都要重复制作一次 rootfs 吗？</p>

<p>比如，我现在用 Ubuntu 操作系统的 ISO 做了一个 rootfs，然后又在里面安装了 Java 环境，用来部署我的 Java 应用。那么，我的另一个同事在发布他的 Java 应用时，显然希望能够直接使用我安装过 Java 环境的 rootfs，而不是重复这个流程。</p>

<p>一种比较直观的解决办法是，我在制作 rootfs 的时候，每做一步“有意义”的操作，就保存一个 rootfs 出来，这样其他同事就可以按需求去用他需要的 rootfs 了。</p>

<p>但是，这个解决办法并不具备推广性。原因在于，一旦你的同事们修改了这个 rootfs，新旧两个 rootfs 之间就没有任何关系了。这样做的结果就是极度的碎片化。</p>

<p>那么，既然这些修改都基于一个旧的 rootfs，我们能不能以增量的方式去做这些修改呢？这样做的好处是，所有人都只需要维护相对于 base rootfs 修改的增量内容，而不是每次修改都制造一个“fork”。</p>

<blockquote>
<p>Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p>
</blockquote>

<p>当然，这个想法不是凭空臆造出来的，而是用到了一种叫作联合文件系统（Union File System）的能力。</p>

<p>Union File System 也叫 UnionFS，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。比如，我现在有两个目录 A 和 B，它们分别有两个文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ tree
.
├── A
│  ├── a
│  └── x
└── B
  ├── b
  └── x</code></pre></td></tr></table>
</div>
</div>
<p>然后，我使用联合挂载的方式，将这两个目录挂载到一个公共的目录 C 上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir C
$ mount -t aufs -o <span class="nv">dirs</span><span class="o">=</span>./A:./B none ./C</code></pre></td></tr></table>
</div>
</div>
<p>这时，我再查看目录 C 的内容，就能看到目录 A 和 B 下的文件被合并到了一起：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ tree ./C
./C
├── a
├── b
└── x</code></pre></td></tr></table>
</div>
</div>
<p>可以看到，在这个合并后的目录 C 里，有 a、b、x 三个文件，并且 x 文件只有一份。这，就是“合并”的含义。此外，如果你在目录 C 里对 a、b、x 文件做修改，这些修改也会在对应的目录 A、B 中生效。</p>

<p>我的环境是 Ubuntu 16.04 和 Docker CE 18.05，这对组合默认使用的是 AuFS 这个联合文件系统的实现。你可以通过 docker info 命令，查看到这个信息。AuFS 的全称是 Another UnionFS，后改名为 Alternative UnionFS，再后来干脆改名叫作 Advance UnionFS.</p>

<h2 id="参考书目">参考书目</h2>

<div class="douban_show">
    <div id="db9787121317866" date-dbid="9787121317866" class="douban_item post-preview"></div>
  </div>

<h2 id="参考文章">参考文章</h2>

<ul>
<li><a href="https://time.geekbang.org/column/article/14642">05 | 白话容器基础（一）：从进程说开去</a></li>
<li><a href="https://time.geekbang.org/column/article/14653">06 | 白话容器基础（二）：隔离与限制</a></li>
<li><a href="https://time.geekbang.org/column/article/17921">07 | 白话容器基础（三）：深入理解容器镜像</a></li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">瞿广</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2019-01-18</span>
  </p>
  
  
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/docker/">docker</a>
          <a href="/tags/%E5%AE%B9%E5%99%A8/">容器</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/course-introduction/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">值得一看的网络课程收集</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/kubernetes-introduction/">
            <span class="next-text nav-default">Kubernetes 入门</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/techqu" class="iconfont icon-github" title="github"></a>
  <a href="https://techqu.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">瞿广</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>






<script src="/js/douban.js"></script>


</body>
</html>
