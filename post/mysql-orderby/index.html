<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>《MYSQL实战45讲》- Order By - Mainroad</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="《MYSQL实战45讲》- Order By" />
<meta property="og:description" content="在你开发应用时，一定会遇到需要根据指定的字段来显式结果的需求。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/mysql-orderby/" />
<meta property="article:published_time" content="2019-03-20T08:49:19+08:00" />
<meta property="article:modified_time" content="2019-03-20T08:49:19+08:00" />

	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《MYSQL实战45讲》- Order By"/>
<meta name="twitter:description" content="在你开发应用时，一定会遇到需要根据指定的字段来显式结果的需求。"/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/syntax.css"><link rel="stylesheet" href="/css/douban.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Mainroad" rel="home">
				<div class="logo__title">Mainroad</div>
				<div class="logo__tagline">Just another site</div>
			</a>
		</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《MYSQL实战45讲》- Order By</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg>
	<time class="meta__text" datetime="2019-03-20T08:49:19">March 20, 2019</time>
</div>

<div class="meta__item-categories meta__item">
	<svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg>
	<span class="meta__text"><a class="meta__link" href="/categories/geektime_note" rel="category">geektime_note</a>, <a class="meta__link" href="/categories/mysql" rel="category">MySQL</a></span>
</div>
</div>
		</header>
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#全字段排序">全字段排序</a></li>
<li><a href="#rowid-排序">rowid 排序</a></li>
<li><a href="#全字段排序-vs-rowid-排序">全字段排序 VS rowid 排序</a></li>
</ul></li>
</ul>
</nav>
	</div>
</div>
<div class="content post__content clearfix">
			<p>在你开发应用时，一定会遇到需要根据指定的字段来显式结果的需求。</p>

<p>假设这个表的部分定义是这样的：</p>

<pre><code>CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `city` varchar(16) NOT NULL,
  `name` varchar(16) NOT NULL,
  `age` int(11) NOT NULL,
  `addr` varchar(128) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `city` (`city`)
) ENGINE=InnoDB;
</code></pre>

<p>SQL可以这么写：</p>

<pre><code>select city,name,age from t where city='杭州' order by name limit 1000  ;
</code></pre>

<h2 id="全字段排序">全字段排序</h2>

<p>MYSQL会给每一个线程分配一块内存用于排序，称为 sort_buffer。</p>

<p>执行流程如下：</p>

<ol>
<li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li>
<li>从索引city找到第一个满足 city=&ldquo;杭州&rdquo;条件的主键id，也就是图中的 ID_X；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，存入 sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4 直到city的值不满足查询条件为止，对应的主键id也就是途中的ID_Y;</li>
<li>对sort_buffer中的数据按照字段name做快速排序；</li>
<li>按照排序结果取前1000行返回给客户端。</li>
</ol>

<p>按照字段name排序，可能在内存中完成，也可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 <code>sort_buffer_size</code></p>

<p><code>sort_buffer_size</code>，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于<code>sort_buffer_size</code>，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>

<h2 id="rowid-排序">rowid 排序</h2>

<p>单行数据量过大的情况</p>

<p>新的算法放入sort_buffer的字段，只有要排序的列（即name字段）的主键id，最后通过主键id回到原表中取出city、name和age三个字段返回给客户端。</p>

<blockquote>
<p><strong>双路排序</strong>：Mysql4.1之前是使用双路排序，字面的意思就是两次扫描磁盘，最终得到数据，读取行指针和ORDER BY列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对数据输出。也就是从磁盘读取排序字段，在buffer进行排序，再从磁盘读取其他字段。文件的磁盘IO非常耗时的，所以在Mysql4.1之后，出现了第二种算法，就是单路排序。</p>

<p><strong>单路排序</strong>：从磁盘读取查询所需要的所有列，按照ORDER BY在buffer对它进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在了内存里。</p>

<p>但是，问题来了，有可能单路排序算法一次拿不出数据，那么就还比双路排序更消耗IO，效率更慢！</p>
</blockquote>

<h2 id="全字段排序-vs-rowid-排序">全字段排序 VS rowid 排序</h2>

<p>如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p>

<p>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p>

<p>这也就体现了MySQL的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问</strong></p>

<p>如果保证从 city 这个索引上取出来的行，天然就是按照name递增排序的话，是不是就可以不用再排序了呢?</p>

<p>确实是这样的，所以我们可以在这个市民表上创建一个city 和 name 的联合索引，对应的 SQL 语句：</p>

<pre><code class="language-sql">alter table t add index city_user(city, name);
</code></pre>

<p>在这个索引里，我们依然可以用树搜索的方式定位到第一个满足city=“杭州”的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name 的值就一定是有序的。</p>

<p>这样整个查询过程的流程就变成了：</p>

<ol>
<li>从索引（city，name）找到第一个满足city=“杭州”条件的主键id；</li>
<li>到主键 id 索引取出整行，取 name、city、age三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引（city，name）取下一个记录主键id；</li>
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city=‘杭州’条件时循环结束</li>
</ol>

<p>可以看到，这个查询过程不需要临时表，也不需要排序。</p>

<p>使用explain语句来印证一下，可以看到 Extra字段中没有 Using filesort了，也就是不需要排序了。而且由于（city，name）这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了。</p>
		</div>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="me avatar" src="/img/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About me</span>
	</div>
	<div class="authorbox__description">
		记录生活的点滴，学习知识，分享知识
	</div>
</div>

<nav class="post-nav flex">
	<div class="post-nav__item post-nav__item--prev">
		<a class="post-nav__link" href="/post/mysql-index-unique-and-normal/" rel="prev"><span class="post-nav__caption">«&thinsp;Previous</span><p class="post-nav__post-title">《MYSQL实战45讲》- 唯一索引和普通索引</p></a>
	</div>
	<div class="post-nav__item post-nav__item--next">
		<a class="post-nav__link" href="/post/data-structure-and-algorithm-merge-sort/" rel="next"><span class="post-nav__caption">Next&thinsp;»</span><p class="post-nav__post-title">《数据结构与算法之美》-归并排序</p></a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2019 Mainroad.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/douban.js"></script></body>
</html>