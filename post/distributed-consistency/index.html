<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>从分布式一致性谈到CAP理论、BASE理论、分布式事务 - Mainroad</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="从分布式一致性谈到CAP理论、BASE理论、分布式事务" />
<meta property="og:description" content="什么是事务，简单说事务就是要么全不做，要么全做。一部分做一部分不做就会出一致性问题。

传统的单体应用不会横跨多个数据库，可以通过单机事务保证一致性。

然而在海量数据的场景下，需要对数据库做拆分，即分库分表，而Cobar、MyCat这类分库分表中间并不提供分布式事务的特性，并且基于二阶段提交的分布式事务性能较差，对于大多数业务场景来说，并不需要强一致，只需要保证最终一致性即可。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/distributed-consistency/" />
<meta property="article:published_time" content="2019-01-14T14:53:02+08:00" />
<meta property="article:modified_time" content="2019-01-14T14:53:02+08:00" />

	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="从分布式一致性谈到CAP理论、BASE理论、分布式事务"/>
<meta name="twitter:description" content="什么是事务，简单说事务就是要么全不做，要么全做。一部分做一部分不做就会出一致性问题。

传统的单体应用不会横跨多个数据库，可以通过单机事务保证一致性。

然而在海量数据的场景下，需要对数据库做拆分，即分库分表，而Cobar、MyCat这类分库分表中间并不提供分布式事务的特性，并且基于二阶段提交的分布式事务性能较差，对于大多数业务场景来说，并不需要强一致，只需要保证最终一致性即可。"/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/syntax.css"><link rel="stylesheet" href="/css/douban.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Mainroad" rel="home">
				<div class="logo__title">Mainroad</div>
				<div class="logo__tagline">Just another site</div>
			</a>
		</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从分布式一致性谈到CAP理论、BASE理论、分布式事务</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg>
	<time class="meta__text" datetime="2019-01-14T14:53:02">January 14, 2019</time>
</div>

<div class="meta__item-categories meta__item">
	<svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg>
	<span class="meta__text"><a class="meta__link" href="/categories/%e4%ba%8b%e5%8a%a1" rel="category">事务</a></span>
</div>
</div>
		</header>
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#理论基础">理论基础</a>
<ul>
<li><a href="#acid">ACID</a></li>
<li><a href="#下面介绍常见的一致性模型">下面介绍常见的一致性模型：</a></li>
<li><a href="#cap理论">CAP理论</a></li>
<li><a href="#cap-理论的延伸-base-理论">CAP 理论的延伸：BASE 理论</a>
<ul>
<li><a href="#1-基本可用">1、基本可用</a></li>
<li><a href="#2-软状态">2、软状态</a></li>
<li><a href="#3-最终一致性">3、最终一致性</a></li>
</ul></li>
<li><a href="#xa规范">XA规范</a></li>
</ul></li>
<li><a href="#分布式一致性协议">分布式一致性协议</a>
<ul>
<li><a href="#分布式事务产生的背景">分布式事务产生的背景</a></li>
<li><a href="#分布式事务">分布式事务</a></li>
</ul></li>
<li><a href="#常见分布式事务解决方案">常见分布式事务解决方案</a></li>
<li><a href="#总结">总结</a>
<ul>
<li><a href="#各方案使用场景">各方案使用场景</a></li>
<li><a href="#分布式事务方案设计">分布式事务方案设计</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
	</div>
</div>
<div class="content post__content clearfix">
			<p>什么是事务，简单说事务就是要么全不做，要么全做。一部分做一部分不做就会出一致性问题。</p>

<p>传统的单体应用不会横跨多个数据库，可以通过单机事务保证一致性。</p>

<p>然而在海量数据的场景下，需要对数据库做拆分，即分库分表，而Cobar、MyCat这类分库分表中间并不提供分布式事务的特性，并且基于二阶段提交的分布式事务性能较差，对于大多数业务场景来说，并不需要强一致，只需要保证最终一致性即可。</p>

<h2 id="理论基础">理论基础</h2>

<h3 id="acid">ACID</h3>

<p>简单而言，ACID 是从不同维度描述事务的特性：</p>

<ul>
<li>原子性：事务操作的整体性。</li>
<li>一致性：事务操作正常或异常下数据的正确性。</li>
<li>隔离性：事务并发操作下数据的正确性。</li>
<li>持久性：事务对数据修改的可靠性。</li>
</ul>

<h3 id="下面介绍常见的一致性模型">下面介绍常见的一致性模型：</h3>

<ul>
<li><strong>强一致性</strong>：要求无论更新操作是在哪个数据副本上执行，之后所有的读操作都要能获得最新的数据。
对于单副本数据来说，读写操作是在同一数据上执行的，容易保证强一致性。对多副本数据来说，则需要使用分布式事务协议。</li>
<li><strong>弱一致性</strong>：在这种一致性下，用户读到某一操作对系统特定数据的更新需要一段时间，我们将这段时间称为&rdquo;不一致性窗口&rdquo;。</li>
<li><strong>最终一致性</strong>：是弱一致性的一种特例，在这种一致性下系统保证用户最终能够读取到某操作对系统特定数据的更新（读取操作之前没有该数据的其他更新操作）。&rdquo;不一致性窗口&rdquo;的大小依赖于交互延迟、系统的负载，以及数据的副本数等。</li>
</ul>

<h3 id="cap理论">CAP理论</h3>

<p><img src="/img/CAP.png" alt="CAP理论" /></p>

<table>
<thead>
<tr>
<th>选择</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>CA</td>
<td>放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择</td>
</tr>

<tr>
<td>AP</td>
<td>放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此</td>
</tr>

<tr>
<td>CP</td>
<td>放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td>
</tr>
</tbody>
</table>

<h3 id="cap-理论的延伸-base-理论">CAP 理论的延伸：BASE 理论</h3>

<p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。接下来看一下BASE中的三要素：</p>

<h4 id="1-基本可用">1、基本可用</h4>

<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性&mdash;-注意，这绝不等价于系统不可用。比如：</p>

<p>（1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒</p>

<p>（2）系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面</p>

<h4 id="2-软状态">2、软状态</h4>

<p>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</p>

<h4 id="3-最终一致性">3、最终一致性</h4>

<p>最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>

<p>总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事务ACID特性是相反的，<strong>它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起</strong>。</p>

<h3 id="xa规范">XA规范</h3>

<p>X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型。 X/Open DTP 模型（ 1994 ）包括<strong>应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ）</strong>四部分。一般，常见的事务管理器（ TM ）是交易中间件，常见的资源管理器（ RM ）是数据库，常见的通信资源管理器（ CRM ）是消息中间件。</p>

<p>通常把一个数据库内部的事务处理，如对多个表的操作，作为本地事务看待。数据库的事务处理对象是本地事务，而分布式事务处理的对象是全局事务。 所谓全局事务，是指分布式事务处理环境中，多个数据库可能需要共同完成一个工作，这个工作即是一个全局事务，例如，一个事务中可能更新几个不同的数据库。对数据库的操作发生在系统的各处但必须全部被提交或回滚。此时一个数据库对自己内部所做操作的提交不仅依赖本身操作是否成功，还要依赖与全局事务相关的其它数据库的操作是否成功，如果任一数据库的任一操作失败，则参与此事务的所有数据库所做的所有操作都必须回滚。 一般情况下，某一数据库无法知道其它数据库在做什么，因此，在一个 DTP 环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。</p>

<p>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。</p>

<h2 id="分布式一致性协议">分布式一致性协议</h2>

<p>　　国际开放标准组织 <a href="http://opengroup.org/">Open Group</a>定义了DTS（分布式事务处理模型），模型中包含4个角色：<strong>应用程序、事务管理器、资源管理器、通信资源管理器</strong>四部分。<strong>事务处理器</strong>是统管全局的<strong>管理者</strong>，<strong>资源处理器</strong>和<strong>通信资源处理器</strong>是事务的<strong>参与者</strong>。</p>

<p>J2EE规范也包含此分布式事务处理模型的规范，并在所有的AppServer中进行实现，J2EE规范中定义了TX协议和XA协议，TX协议定义应用程序与事务管理器之间的接口，而XA协议定义了事务管理器与资源处理器之间的接口，在过去，大家使用AppServer，例如：Websphere、Weblogic、Jboss等配置数据源的时候会看见类似XADatasource的数据源，这就是实现了DTS的关系型数据库的数据源。企业级开发JEE中，关系型数据库、JMS服务扮演资源管理器的角色，而EJB容器则扮演事务管理器的角色。</p>

<p><a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">两阶段提交协议</a>、<a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol">三阶段提交协议</a>以及阿里巴巴提出的TCC，它们都是根据DTS这一思想演变出来的。</p>

<h3 id="分布式事务产生的背景">分布式事务产生的背景</h3>

<p>随着分布式计算的发展，事务在分布式计算领域也得到了广泛的应用。在单机数据库中，我们很容易能够实现一套满足ACID特性的事务处理系统，但在分布式数据库中，数据分散在各台不同的机器上，如何对这些数据进行分布式的事务处理具有非常大的挑战。</p>

<p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上，通常一个分布式事务中会涉及对多个数据源或业务系统的操作。</p>

<p>可以设想一个最典型的分布式事务场景：一个跨银行的转账操作涉及调用两个异地的银 行服务，其中一个是本地银行提供的取款服务，另一个则是目标银行提供的存款服务，这两个服务本身是无状态并且相互独立的，共同构成了一个完整的分布式事 物。如果从本地银行取款成功，但是因为某种原因存款服务失败了，那么就必须回滚到取款之前的状态，否则用户可能会发现自己的钱不翼而飞了。</p>

<p>从这个例子可以看到，一个分布式事务可以看做是多个分布式的操作序列组成的，例如 上面例子的取款服务和存款服务，通常可以把这一系列分布式的操作序列称为子事务。因此，分布式事务也可以被定义为一种嵌套型的事务，同时也就具有了 ACID事务特性。但由于在分布式事务中，各个子事务的执行是分布式的，因此要实现一种能够保证ACID特性的分布式事务处理系统就显得格外复杂。</p>

<h3 id="分布式事务">分布式事务</h3>

<p>分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）</p>

<h2 id="常见分布式事务解决方案">常见分布式事务解决方案</h2>

<p>分布式事务的实现有许多种，其中较经典是由 Tuxedo 提出的 XA 分布式事务协议，XA 协议包含二阶段提交（2PC）和三阶段提交（3PC）两种实现，消息中间件、tcc、gts、提供回滚接口、分布式数据库，<a href="http://www.txlcn.org/zh-cn/">基于SpringCloud的分布式事务框架(LCN)</a>，<a href="https://github.com/alibaba/fescar/wiki/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-FESCAR">阿里巴巴开源分布式事务解决方案 FESCAR</a>等。</p>

<h2 id="总结">总结</h2>

<h3 id="各方案使用场景">各方案使用场景</h3>

<table>
<thead>
<tr>
<th></th>
<th>2PC</th>
<th>3PC</th>
<th>TCC</th>
<th>本地消息表</th>
<th>MQ事务</th>
<th>Sage</th>
</tr>
</thead>

<tbody>
<tr>
<td>数据一致性</td>
<td>强</td>
<td>强</td>
<td>弱</td>
<td>弱</td>
<td>弱</td>
<td>弱</td>
</tr>

<tr>
<td>容错性</td>
<td>低</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>

<tr>
<td>复杂性</td>
<td>中</td>
<td>高</td>
<td>高</td>
<td>低</td>
<td>低</td>
<td>中</td>
</tr>

<tr>
<td>性能</td>
<td>低</td>
<td>低</td>
<td>中</td>
<td>中</td>
<td>高</td>
<td>中</td>
</tr>

<tr>
<td>维护成本</td>
<td>低</td>
<td>中</td>
<td>高</td>
<td>中</td>
<td>中</td>
<td>高</td>
</tr>
</tbody>
</table>

<p>介绍完分布式事务相关理论和常见解决方案后，最终的目的在实际项目中运用，因此，总结一下各个方案的常见的使用场景：</p>

<ul>
<li><p><strong>2PC/3PC</strong>：依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</p></li>

<li><p><strong>TCC</strong>：适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</p></li>

<li><p><strong>本地消息表/MQ</strong>
事务：都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</p></li>

<li><p><strong>Saga 事务</strong>：由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。
Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</p></li>
</ul>

<h3 id="分布式事务方案设计">分布式事务方案设计</h3>

<p>本文介绍的偏向于原理，业界已经有不少开源的或者收费的解决方案，篇幅所限，就不再展开介绍。</p>

<p>实际运用理论时进行架构设计时，许多人容易犯“手里有了锤子，看什么都觉得像钉子”的错误，设计方案时考虑的问题场景过多，各种重试，各种补偿机制引入系统，导致系统过于复杂，落地遥遥无期。</p>

<p><div class="admonition quote"></p>

<p>世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！</p>

<p>—— 阿里中间件技术专家沈询</p>

<p></div>
有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。</p>

<p>设计分布式事务系统也不是需要考虑所有异常情况，不必过度设计各种回滚，补偿机制。</p>

<p>如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。</p>

<p>如果系统要实现回滚流程的话，有可能系统复杂度将大大提升，且很容易出现 Bug，估计出现 Bug 的概率会比需要事务回滚的概率大很多。</p>

<p>在设计系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，可以考虑当出现这个概率很小的问题，能否采用人工解决的方式，这也是大家在解决疑难问题时需要多多思考的地方。</p>
		</div>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="me avatar" src="/img/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About me</span>
	</div>
	<div class="authorbox__description">
		记录生活的点滴，学习知识，分享知识
	</div>
</div>

<nav class="post-nav flex">
	<div class="post-nav__item post-nav__item--prev">
		<a class="post-nav__link" href="/post/transaction-2pc/" rel="prev"><span class="post-nav__caption">«&thinsp;Previous</span><p class="post-nav__post-title">分布式事务-2PC(二阶段提交)</p></a>
	</div>
	<div class="post-nav__item post-nav__item--next">
		<a class="post-nav__link" href="/post/transaction-local-msg-tb/" rel="next"><span class="post-nav__caption">Next&thinsp;»</span><p class="post-nav__post-title">分布式事务-本地消息表：最终一致性</p></a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2019 Mainroad.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/douban.js"></script></body>
</html>