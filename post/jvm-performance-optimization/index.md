
 linux性能调优和年轻代大小选择和年老代大小的选择
<!--more-->


## 1.性能优化是什么
就是发挥机器本来的性能

## 2.性能的几个维度
### 1.CPU

1. `vmstat`

http://www.man7.org/linux/man-pages/man8/vmstat.8.html

首先检查 cpu，cpu 使用率要提升而不是降低,
CPU 空闲并不一定是没事做，也有可能是锁或者外部资源瓶颈。

2. `top`

### 2. IO

- 命令：iostat
- 如： `iostat -xd l`
- 地址：http://www.man7.org/linux/man-pages/man1/iostat.1.html
    
### 3.Memory
    
- 命令 free
- 如：`free -g`

### 4.Network

## cpu负载高如何定位


A.`top`找到cpu高的进程（原理：方法是由线程执行的，线程是在进程下，找到进程下cpu最高的线程就能定位到方法）

B.`shift+H` 切换到线程模型 找到线程执行cpu高的线程号

C.用jstack导出线程的dump
`Jstack pid > p.txt  `

有时候这个问题没有那么明显一致cpu很高，
可能是间歇性的cpu高，有时候能抓住这个线程还是要看运气

D.把线程号转16进制 printf "%x \n" 40437

F.到刚刚导出的p.txt里检索定位到 转完16进制的线程号



## 年轻代大小选择
1. 响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。
2. 吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。

## 年老代大小选择
1. 响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。

    如果堆设置小了，可 以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；
    
    如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：
    - 并发垃圾收集信息
    - 持久代并发收集次数
    - 传统GC信息
    - 花在年轻代和年老代回收上的时间比例
    - 减少年轻代和年老代花费的时间，一般会提高应用的效率
2. 吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。
较小堆引起的碎片问题

    因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对 象。
    
    但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记-清除方式进行回收。
    如果出现“碎片”，可能需要进行如下JVM参数配置：
    -XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。
    -XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩
    JVM的内存限制
