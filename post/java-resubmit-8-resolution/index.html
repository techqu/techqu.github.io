<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>8种方案解决重复提交问题 - quguang&#39;s blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="8种方案解决重复提交问题" />
<meta property="og:description" content="
作者：锦成同学

链接：juejin.im/post/5d31928c51882564c966a71c
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/java-resubmit-8-resolution/" />
<meta property="article:published_time" content="2019-08-26T20:40:12+08:00" />
<meta property="article:modified_time" content="2019-08-26T20:40:12+08:00" />

	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="8种方案解决重复提交问题"/>
<meta name="twitter:description" content="
作者：锦成同学

链接：juejin.im/post/5d31928c51882564c966a71c
"/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/douban.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="quguang&#39;s blog" rel="home">
				<div class="logo__title">quguang&#39;s blog</div>
				<div class="logo__tagline">不动笔墨不读书</div>
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/post/2018-2019/">2018-2019</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">about me</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/post/learn-method/">learn method</a>
		</li>
	</ul>
</nav>

	</div>
<link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/dracula.min.css" rel="stylesheet">


</header>
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/django.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/vim.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/yaml.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/gradle.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/tex.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.9/languages/shell.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/http.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">8种方案解决重复提交问题</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg>
	<time class="meta__text" datetime="2019-08-26T20:40:12">August 26, 2019</time>
</div>
</div>
		</header>
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#1-什么是幂等">1.什么是幂等</a></li>
<li><a href="#2-产生原因">2.产生原因</a></li>
<li><a href="#3-解决方案">3.解决方案</a>
<ul>
<li><a href="#1-前端js提交禁止按钮可以用一些js组件">1. 前端js提交禁止按钮可以用一些js组件</a></li>
<li><a href="#2-使用post-redirect-get模式">2. 使用Post/Redirect/Get模式</a></li>
<li><a href="#3-在session中存放一个特殊标志">3. 在session中存放一个特殊标志</a></li>
<li><a href="#4-其他借助使用header头设置缓存控制头cache-control等方式">4. 其他借助使用header头设置缓存控制头Cache-control等方式</a></li>
<li><a href="#5-借助数据库">5. 借助数据库</a></li>
<li><a href="#6-借助悲观锁">6. 借助悲观锁</a></li>
<li><a href="#7-借助本地锁-本文重点">7. 借助本地锁(本文重点)</a>
<ul>
<li><a href="#①配置注解">①配置注解</a></li>
<li><a href="#②实例化锁">②实例化锁</a></li>
<li><a href="#③aop-切面">③AOP 切面</a></li>
<li><a href="#④注解使用案例">④注解使用案例</a></li>
</ul></li>
<li><a href="#8-借助分布式redis锁-参考其他">8)借助分布式redis锁 （参考其他）</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
	</div>
</div>
<div class="content post__content clearfix">
			<blockquote>
<p>作者：锦成同学</p>

<p>链接：juejin.im/post/5d31928c51882564c966a71c</p>
</blockquote>

<h3 id="1-什么是幂等">1.什么是幂等</h3>

<p>在我们编程中常见幂等</p>

<ul>
<li>select查询天然幂等</li>
<li>delete删除也是幂等,删除同一个多次效果一样</li>
<li>update直接更新某个值的,幂等</li>
<li>update更新累加操作的,非幂等</li>
<li>insert非幂等操作,每次新增一条</li>
</ul>

<h3 id="2-产生原因">2.产生原因</h3>

<p>由于重复点击或者网络重发</p>

<p>eg:</p>

<ul>
<li>点击提交按钮两次;</li>
<li>点击刷新按钮;</li>
<li>使用浏览器后退按钮重复之前的操作，导致重复提交表单;</li>
<li>使用浏览器历史记录重复提交表单;</li>
<li>浏览器重复的HTTP请;</li>
<li>nginx重发等情况;</li>
<li>分布式RPC的try重发等;</li>
</ul>

<h3 id="3-解决方案">3.解决方案</h3>

<h4 id="1-前端js提交禁止按钮可以用一些js组件">1. 前端js提交禁止按钮可以用一些js组件</h4>

<h4 id="2-使用post-redirect-get模式">2. 使用Post/Redirect/Get模式</h4>

<p>在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按F5导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。</p>

<h4 id="3-在session中存放一个特殊标志">3. 在session中存放一个特殊标志</h4>

<p>在服务器端，生成一个唯一的标识符，将它存入session，同时将它写入表单的隐藏字段中，然后将表单页面发给浏览器，用户录入信息后点击提交，在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除；不相等说明是重复提交，就不再处理。</p>

<h4 id="4-其他借助使用header头设置缓存控制头cache-control等方式">4. 其他借助使用header头设置缓存控制头Cache-control等方式</h4>

<p>比较复杂 不适合移动端APP的应用 这里不详解</p>

<h4 id="5-借助数据库">5. 借助数据库</h4>

<p>insert使用唯一索引 update使用 乐观锁 version版本法</p>

<p>这种在大数据量和高并发下效率依赖数据库硬件能力,可针对非核心业务</p>

<h4 id="6-借助悲观锁">6. 借助悲观锁</h4>

<p>使用select … for update ,这种和 synchronized 锁住先查再insert or update一样,但要避免死锁,效率也较差</p>

<p>针对单体 请求并发不大 可以推荐使用</p>

<h4 id="7-借助本地锁-本文重点">7. 借助本地锁(本文重点)</h4>

<p>原理:</p>

<p>使用了 ConcurrentHashMap 并发容器 putIfAbsent 方法,和 ScheduledThreadPoolExecutor 定时任务,也可以使用guava cache的机制, gauva中有配有缓存的有效时间也是可以的key的生成 Content-MD5 Content-MD5 是指 Body 的 MD5 值，只有当 Body 非Form表单时才计算MD5，计算方式直接将参数和参数名称统一加密MD5 MD5在一定范围类认为是唯一的 近似唯一 当然在低并发的情况下足够了</p>

<p>本地锁只适用于单机部署的应用.</p>

<h5 id="①配置注解">①配置注解</h5>

<pre><code class="language-java">import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Resubmit {

    /**
     * 延时时间 在延时多久后可以再次提交
     *
     * @return Time unit is one second
     */
    int delaySeconds() default 20;
}
</code></pre>

<h5 id="②实例化锁">②实例化锁</h5>

<pre><code class="language-java">import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.digest.DigestUtils;

import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author lijing
 * 重复提交锁
 */
@Slf4j
public final class ResubmitLock {


    private static final ConcurrentHashMap&lt;String, Object&gt; LOCK_CACHE = new ConcurrentHashMap&lt;&gt;(200);
    private static final ScheduledThreadPoolExecutor EXECUTOR = new ScheduledThreadPoolExecutor(5, new ThreadPoolExecutor.DiscardPolicy());


   // private static final Cache&lt;String, Object&gt; CACHES = CacheBuilder.newBuilder()
            // 最大缓存 100 个
   //          .maximumSize(1000)
            // 设置写缓存后 5 秒钟过期
   //         .expireAfterWrite(5, TimeUnit.SECONDS)
   //         .build();


    private ResubmitLock() {
    }

    /**
     * 静态内部类 单例模式
     *
     * @return
     */
    private static class SingletonInstance {
        private static final ResubmitLock INSTANCE = new ResubmitLock();
    }

    public static ResubmitLock getInstance() {
        return SingletonInstance.INSTANCE;
    }


    public static String handleKey(String param) {
        return DigestUtils.md5Hex(param == null ? &quot;&quot; : param);
    }

    /**
     * 加锁 putIfAbsent 是原子操作保证线程安全
     *
     * @param key   对应的key
     * @param value
     * @return
     */
    public boolean lock(final String key, Object value) {
        return Objects.isNull(LOCK_CACHE.putIfAbsent(key, value));
    }

    /**
     * 延时释放锁 用以控制短时间内的重复提交
     *
     * @param lock         是否需要解锁
     * @param key          对应的key
     * @param delaySeconds 延时时间
     */
    public void unLock(final boolean lock, final String key, final int delaySeconds) {
        if (lock) {
            EXECUTOR.schedule(() -&gt; {
                LOCK_CACHE.remove(key);
            }, delaySeconds, TimeUnit.SECONDS);
        }
    }
}
</code></pre>

<h5 id="③aop-切面">③AOP 切面</h5>

<pre><code class="language-java">import com.alibaba.fastjson.JSONObject;
import com.cn.xxx.common.annotation.Resubmit;
import com.cn.xxx.common.annotation.impl.ResubmitLock;
import com.cn.xxx.common.dto.RequestDTO;
import com.cn.xxx.common.dto.ResponseDTO;
import com.cn.xxx.common.enums.ResponseCode;
import lombok.extern.log4j.Log4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

/**
 * @ClassName RequestDataAspect
 * @Description 数据重复提交校验
 * @Author lijing
 * @Date 2019/05/16 17:05
 **/
@Log4j
@Aspect
@Component
public class ResubmitDataAspect {

    private final static String DATA = &quot;data&quot;;
    private final static Object PRESENT = new Object();

    @Around(&quot;@annotation(com.cn.xxx.common.annotation.Resubmit)&quot;)
    public Object handleResubmit(ProceedingJoinPoint joinPoint) throws Throwable {
        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
        //获取注解信息
        Resubmit annotation = method.getAnnotation(Resubmit.class);
        int delaySeconds = annotation.delaySeconds();
        Object[] pointArgs = joinPoint.getArgs();
        String key = &quot;&quot;;
        //获取第一个参数
        Object firstParam = pointArgs[0];
        if (firstParam instanceof RequestDTO) {
            //解析参数
            JSONObject requestDTO = JSONObject.parseObject(firstParam.toString());
            JSONObject data = JSONObject.parseObject(requestDTO.getString(DATA));
            if (data != null) {
                StringBuffer sb = new StringBuffer();
                data.forEach((k, v) -&gt; {
                    sb.append(v);
                });
                //生成加密参数 使用了content_MD5的加密方式
                key = ResubmitLock.handleKey(sb.toString());
            }
        }
        //执行锁
        boolean lock = false;
        try {
            //设置解锁key
            lock = ResubmitLock.getInstance().lock(key, PRESENT);
            if (lock) {
                //放行
                return joinPoint.proceed();
            } else {
                //响应重复提交异常
                return new ResponseDTO&lt;&gt;(ResponseCode.REPEAT_SUBMIT_OPERATION_EXCEPTION);
            }
        } finally {
            //设置解锁key和解锁时间
            ResubmitLock.getInstance().unLock(lock, key, delaySeconds);
        }
    }
}
</code></pre>

<h5 id="④注解使用案例">④注解使用案例</h5>

<pre><code class="language-java">@ApiOperation(value = &quot;保存我的帖子接口&quot;, notes = &quot;保存我的帖子接口&quot;)
    @PostMapping(&quot;/posts/save&quot;)
    @Resubmit(delaySeconds = 10)
    public ResponseDTO&lt;BaseResponseDataDTO&gt; saveBbsPosts(@RequestBody @Validated RequestDTO&lt;BbsPostsRequestDTO&gt; requestDto) {
        return bbsPostsBizService.saveBbsPosts(requestDto);
    }
</code></pre>

<p>以上就是本地锁的方式进行的幂等提交 使用了Content-MD5 进行加密 只要参数不变,参数加密 密值不变,key存在就阻止提交</p>

<p>当然也可以使用 一些其他签名校验 在某一次提交时先 生成固定签名 提交到后端 根据后端解析统一的签名作为 每次提交的验证token 去缓存中处理即可.</p>

<h4 id="8-借助分布式redis锁-参考其他">8)借助分布式redis锁 （参考其他）</h4>

<p>也可以参考这篇：基于redis的分布式锁的分析与实践
在 pom.xml 中添加上 starter-web、starter-aop、starter-data-redis 的依赖即可</p>

<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>属性配置 在 application.properites 资源文件中添加 redis 相关的配置项</p>

<pre><code>spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=123456
</code></pre>

<p>主要实现方式:</p>

<p>熟悉 Redis 的朋友都知道它是线程安全的，我们利用它的特性可以很轻松的实现一个分布式锁，如 opsForValue().setIfAbsent(key,value)它的作用就是如果缓存中没有当前 Key 则进行缓存同时返回 true 反之亦然；</p>

<p>当缓存后给 key 在设置个过期时间，防止因为系统崩溃而导致锁迟迟不释放形成死锁；那么我们是不是可以这样认为当返回 true 我们认为它获取到锁了，在锁未释放的时候我们进行异常的抛出…</p>

<pre><code class="language-java">package com.battcn.interceptor;

import com.battcn.annotation.CacheLock;
import com.battcn.utils.RedisLockHelper;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.util.StringUtils;

import java.lang.reflect.Method;
import java.util.UUID;

/**
 * redis 方案
 *
 * @author Levin
 * @since 2018/6/12 0012
 */
@Aspect
@Configuration
public class LockMethodInterceptor {

    @Autowired
    public LockMethodInterceptor(RedisLockHelper redisLockHelper, CacheKeyGenerator cacheKeyGenerator) {
        this.redisLockHelper = redisLockHelper;
        this.cacheKeyGenerator = cacheKeyGenerator;
    }

    private final RedisLockHelper redisLockHelper;
    private final CacheKeyGenerator cacheKeyGenerator;


    @Around(&quot;execution(public * *(..)) &amp;&amp; @annotation(com.battcn.annotation.CacheLock)&quot;)
    public Object interceptor(ProceedingJoinPoint pjp) {
        MethodSignature signature = (MethodSignature) pjp.getSignature();
        Method method = signature.getMethod();
        CacheLock lock = method.getAnnotation(CacheLock.class);
        if (StringUtils.isEmpty(lock.prefix())) {
            throw new RuntimeException(&quot;lock key don't null...&quot;);
        }
        final String lockKey = cacheKeyGenerator.getLockKey(pjp);
        String value = UUID.randomUUID().toString();
        try {
            // 假设上锁成功，但是设置过期时间失效，以后拿到的都是 false
            final boolean success = redisLockHelper.lock(lockKey, value, lock.expire(), lock.timeUnit());
            if (!success) {
                throw new RuntimeException(&quot;重复提交&quot;);
            }
            try {
                return pjp.proceed();
            } catch (Throwable throwable) {
                throw new RuntimeException(&quot;系统异常&quot;);
            }
        } finally {
            // TODO 如果演示的话需要注释该代码;实际应该放开
            redisLockHelper.unlock(lockKey, value);
        }
    }
}
</code></pre>

<p>RedisLockHelper 通过封装成 API 方式调用，灵活度更加高</p>

<pre><code class="language-java">package com.battcn.utils;

import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisStringCommands;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.types.Expiration;
import org.springframework.util.StringUtils;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

/**
 * 需要定义成 Bean
 *
 * @author Levin
 * @since 2018/6/15 0015
 */
@Configuration
@AutoConfigureAfter(RedisAutoConfiguration.class)
public class RedisLockHelper {


    private static final String DELIMITER = &quot;|&quot;;

    /**
     * 如果要求比较高可以通过注入的方式分配
     */
    private static final ScheduledExecutorService EXECUTOR_SERVICE = Executors.newScheduledThreadPool(10);

    private final StringRedisTemplate stringRedisTemplate;

    public RedisLockHelper(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    /**
     * 获取锁（存在死锁风险）
     *
     * @param lockKey lockKey
     * @param value   value
     * @param time    超时时间
     * @param unit    过期单位
     * @return true or false
     */
    public boolean tryLock(final String lockKey, final String value, final long time, final TimeUnit unit) {
        return stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.set(lockKey.getBytes(), value.getBytes(), Expiration.from(time, unit), RedisStringCommands.SetOption.SET_IF_ABSENT));
    }

    /**
     * 获取锁
     *
     * @param lockKey lockKey
     * @param uuid    UUID
     * @param timeout 超时时间
     * @param unit    过期单位
     * @return true or false
     */
    public boolean lock(String lockKey, final String uuid, long timeout, final TimeUnit unit) {
        final long milliseconds = Expiration.from(timeout, unit).getExpirationTimeInMilliseconds();
        boolean success = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, (System.currentTimeMillis() + milliseconds) + DELIMITER + uuid);
        if (success) {
            stringRedisTemplate.expire(lockKey, timeout, TimeUnit.SECONDS);
        } else {
            String oldVal = stringRedisTemplate.opsForValue().getAndSet(lockKey, (System.currentTimeMillis() + milliseconds) + DELIMITER + uuid);
            final String[] oldValues = oldVal.split(Pattern.quote(DELIMITER));
            if (Long.parseLong(oldValues[0]) + 1 &lt;= System.currentTimeMillis()) {
                return true;
            }
        }
        return success;
    }


    /**
     * @see &lt;a href=&quot;http://redis.io/commands/set&quot;&gt;Redis Documentation: SET&lt;/a&gt;
     */
    public void unlock(String lockKey, String value) {
        unlock(lockKey, value, 0, TimeUnit.MILLISECONDS);
    }

    /**
     * 延迟unlock
     *
     * @param lockKey   key
     * @param uuid      client(最好是唯一键的)
     * @param delayTime 延迟时间
     * @param unit      时间单位
     */
    public void unlock(final String lockKey, final String uuid, long delayTime, TimeUnit unit) {
        if (StringUtils.isEmpty(lockKey)) {
            return;
        }
        if (delayTime &lt;= 0) {
            doUnlock(lockKey, uuid);
        } else {
            EXECUTOR_SERVICE.schedule(() -&gt; doUnlock(lockKey, uuid), delayTime, unit);
        }
    }

    /**
     * @param lockKey key
     * @param uuid    client(最好是唯一键的)
     */
    private void doUnlock(final String lockKey, final String uuid) {
        String val = stringRedisTemplate.opsForValue().get(lockKey);
        final String[] values = val.split(Pattern.quote(DELIMITER));
        if (values.length &lt;= 0) {
            return;
        }
        if (uuid.equals(values[1])) {
            stringRedisTemplate.delete(lockKey);
        }
    }

}
</code></pre>

<blockquote>
<p>redis的提交参照</p>

<p><a href="https://blog.battcn.com/2018/06/13/springboot/v2-cache-redislock/">https://blog.battcn.com/2018/06/13/springboot/v2-cache-redislock/</a></p>
</blockquote>
		</div>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="me avatar" src="/img/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About me</span>
	</div>
	<div class="authorbox__description">
		不动笔墨不读书
	</div>
</div>

<nav class="post-nav flex">
	<div class="post-nav__item post-nav__item--prev">
		<a class="post-nav__link" href="/post/java-retry-best-practice/" rel="prev"><span class="post-nav__caption">«&thinsp;Previous</span><p class="post-nav__post-title">【最佳实践】如何优雅的进行重试</p></a>
	</div>
	<div class="post-nav__item post-nav__item--next">
		<a class="post-nav__link" href="/post/mongo-aggregate/" rel="next"><span class="post-nav__caption">Next&thinsp;»</span><p class="post-nav__post-title">MongoDB中聚合工具Aggregate等的介绍与使用</p></a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2019 quguang&#39;s blog.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/douban.js"></script></body>
</html>