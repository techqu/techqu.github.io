<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Tomcat&amp;Netty-Tomcat系统架构(下):聊聊多层容器的设计 - quguang&#39;s blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="Tomcat&amp;Netty-Tomcat系统架构(下):聊聊多层容器的设计" />
<meta property="og:description" content="专栏上一期我们学完了连接器的设计，今天我们一起来看一下Tomcat的容器设计。先复习一下，上期我讲 到了Tomcat有两个核心组件:连接器和容器，其中连接器负责外部交流，容器负责内部处理。具体来说就是


连接器处理Socket通信和应用层协议的解析，得到Servlet请求;
而容器则负责处理Servlet请求。
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/geektime-tomcat-netty-03/" />
<meta property="article:published_time" content="2019-09-17T16:19:34+08:00" />
<meta property="article:modified_time" content="2019-09-17T16:19:34+08:00" />

	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tomcat&amp;Netty-Tomcat系统架构(下):聊聊多层容器的设计"/>
<meta name="twitter:description" content="专栏上一期我们学完了连接器的设计，今天我们一起来看一下Tomcat的容器设计。先复习一下，上期我讲 到了Tomcat有两个核心组件:连接器和容器，其中连接器负责外部交流，容器负责内部处理。具体来说就是


连接器处理Socket通信和应用层协议的解析，得到Servlet请求;
而容器则负责处理Servlet请求。
"/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/douban.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="quguang&#39;s blog" rel="home">
				<div class="logo__title">quguang&#39;s blog</div>
				<div class="logo__tagline">不动笔墨不读书</div>
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/post/2018-2019/">2018-2019</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">about me</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/post/learn-method/">learn method</a>
		</li>
	</ul>
</nav>

	</div>
<link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/dracula.min.css" rel="stylesheet">


</header>
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/django.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/vim.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/yaml.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/gradle.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/tex.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.9/languages/shell.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/http.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Tomcat&amp;Netty-Tomcat系统架构(下):聊聊多层容器的设计</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg>
	<time class="meta__text" datetime="2019-09-17T16:19:34">September 17, 2019</time>
</div>

<div class="meta__item-categories meta__item">
	<svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg>
	<span class="meta__text"><a class="meta__link" href="/categories/geektime" rel="category">geektime</a>, <a class="meta__link" href="/categories/" rel="category">《》</a></span>
</div>
</div>
		</header>
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#容器的层次结构">容器的层次结构</a>
<ul>
<li><a href="#请求定位servlet的过程">请求定位Servlet的过程</a></li>
<li><a href="#1-首先-根据协议和端口号选定service和engine">1. 首先，根据协议和端口号选定Service和Engine。</a></li>
<li><a href="#2-然后-根据域名选定host">2. 然后，根据域名选定Host。</a></li>
<li><a href="#3-之后-根据url路径找到context组件">3. 之后，根据URL路径找到Context组件。</a></li>
<li><a href="#4-最后-根据url路径找到wrapper-servlet">4. 最后，根据URL路径找到Wrapper(Servlet)。</a></li>
</ul></li>
<li><a href="#pipeline-valve管道">Pipeline-Valve管道</a>
<ul>
<li><a href="#本期精华">本期精华</a></li>
</ul></li>
<li><a href="#课后思考">课后思考</a></li>
<li><a href="#精选留言">精选留言:</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
	</div>
</div>
<div class="content post__content clearfix">
			<p>专栏上一期我们学完了连接器的设计，今天我们一起来看一下Tomcat的容器设计。先复习一下，上期我讲 到了Tomcat有两个核心组件:<strong>连接器和容器</strong>，其中连接器负责外部交流，容器负责内部处理。具体来说就是</p>

<ul>
<li>连接器处理Socket通信和应用层协议的解析，得到Servlet请求;</li>
<li>而容器则负责处理Servlet请求。</li>
</ul>

<p>我们通过下面这张图来回忆一下。</p>

<p><img src="/img/geektime-tomcat-connector-container.png" alt="img/geektime-tomcat-connector-container.png" /></p>

<p>容器，顾名思义就是用来装载东西的器具，在Tomcat里，容器就是用来装载Servlet的。那Tomcat的Servlet 容器是如何设计的呢?</p>

<h3 id="容器的层次结构">容器的层次结构</h3>

<p>Tomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。这4种容器不是平行关系，而是父子关系。下面我画了一张图帮你理解它们的关系。</p>

<p>你可能会问，为什么要设计成这么多层次的容器，这不是增加了复杂度吗?其实这背后的考虑是，<strong>Tomcat 通过一种分层的架构，使得Servlet容器具有很好的灵活性。</strong></p>

<ul>
<li>Context表示一个Web应用程序;</li>
<li>Wrapper表示一个Servlet，一个Web应用程序中可能会有多个Servlet;</li>
<li>Host代表的是一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下 可以部署多个Web应用程序;</li>
<li>Engine表示引擎，用来管理多个虚拟站点，一个Service最多只能有一个 Engine。</li>
</ul>

<p>你可以再通过Tomcat的server.xml配置文件来加深对Tomcat容器的理解。Tomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的格式要求配置在这个顶层容器中。</p>

<pre><code class="language-xml">&lt;Server&gt;   //顶层组件，可以包含多个 Service
  &lt;Service&gt;//顶层组件，可以包含一个 Engine，多个连接器

    &lt;Connector&gt; //连接器组件，代表通信接口
    &lt;/Connector&gt;

    &lt;Engine&gt;    //容器组件，一个 Engine组件处理 Service 中的所有请求，包含多个 Host
        &lt;Host&gt;  //容器组件，处理特定的 Host 下客户请求，可包含多个 Context
          &lt;Context&gt;//容器组件，为特定的 Web 应用处理所有的客户请求
          &lt;/Context&gt;
        &lt;/Host&gt;
    &lt;/Engine&gt;

  &lt;/Service&gt;
&lt;/Server&gt;
</code></pre>

<p>那么，Tomcat是怎么管理这些容器的呢?你会发现这些容器具有父子关系，形成一个树形结构，你可能马 上就想到了设计模式中的组合模式。没错，Tomcat就是用组合模式来管理这些容器的。具体实现方法是， 所有容器组件都实现了Container接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具 有一致性。这里单容器对象指的是最底层的Wrapper，组合容器对象指的是上面的Context、Host或者 Engine。Container接口定义如下:</p>

<pre><code class="language-java">  public interface Container extends Lifecycle {
      public void setName(String name);
      public Container getParent();
      public void setParent(Container container);
      public void addChild(Container child);
      public void removeChild(Container child);
      public Container findChild(String name);
}
</code></pre>

<p>正如我们期望的那样，我们在上面的接口看到了getParent、SetParent、addChild和removeChild等方法。 你可能还注意到Container接口扩展了LifeCycle接口，LifeCycle接口用来统一管理各组件的生命周期，后面 我也用专门的篇幅去详细介绍。</p>

<h4 id="请求定位servlet的过程">请求定位Servlet的过程</h4>

<p>你可能好奇，设计了这么多层次的容器，Tomcat是怎么确定请求是由哪个Wrapper容器里的Servlet来处理 的呢?答案是，Tomcat是用Mapper组件来完成这个任务的。</p>

<p>Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是:Mapper组件里保存了Web 应用的配置信息，其实就是<strong>容器组件与访问路径的映射关系</strong>，比如Host容器里配置的域名、Context容器里 的Web应用路径，以及Wrapper容器里Servlet映射的路径，你可以想象这些配置信息就是一个多层次的 Map。</p>

<p>当一个请求到来时，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去查找，就能 定位到一个Servlet。请你注意，一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet。</p>

<p>读到这里你可能感到有些抽象，接下来我通过一个例子来解释这个定位的过程。</p>

<p>假如有一个网购系统，有面向网站管理人员的后台管理系统，还有面向终端客户的在线购物系统。这两个系统跑在同一个Tomcat上，为了隔离它们的访问域名，配置了两个虚拟域名:manage.shopping.com和 user.shopping.com，网站管理人员通过manage.shopping.com域名访问Tomcat去管理用户和商品， 而用户管理和商品管理是两个单独的Web应用。终端客户通过user.shopping.com域名去搜索商品和下订单，搜索功能和订单管理也是两个独立的Web应用。</p>

<p>针对这样的部署，Tomcat会创建一个Service组件和一个Engine容器组件，在Engine容器下创建两个Host子 容器，在每个Host容器下创建两个Context子容器。由于一个Web应用通常有多个Servlet，Tomcat还会在每 个Context容器里创建多个Wrapper子容器。每个容器都有对应的访问路径，你可以通过下面这张图来帮助 你理解。</p>

<p><img src="/img/geektime-tomcat-shopping.png" alt="geektime-tomcat-shopping.png" /></p>

<p>假如有用户访问一个URL，比如图中的<a href="http://user.shopping.com:8080/order/buy，Tomcat如何将这个URL定位到一个Servlet呢?">http://user.shopping.com:8080/order/buy，Tomcat如何将这个URL定位到一个Servlet呢?</a></p>

<h4 id="1-首先-根据协议和端口号选定service和engine">1. 首先，根据协议和端口号选定Service和Engine。</h4>

<p>我们知道Tomcat的每个连接器都监听不同的端口，比如Tomcat默认的HTTP连接器监听8080端口、默认的 AJP连接器监听8009端口。上面例子中的URL访问的是8080端口，因此这个请求会被HTTP连接器接收，而一 个连接器是属于一个Service组件的，这样Service组件就确定了。我们还知道一个Service组件里除了有多个 连接器，还有一个容器组件，具体来说就是一个Engine容器，因此Service确定了也就意味着Engine也确定了。</p>

<h4 id="2-然后-根据域名选定host">2. 然后，根据域名选定Host。</h4>

<p>Service和Engine确定后，Mapper组件通过URL中的域名去查找相应的Host容器，比如例子中的URL访问的 域名是user.shopping.com，因此Mapper会找到Host2这个容器。</p>

<h4 id="3-之后-根据url路径找到context组件">3. 之后，根据URL路径找到Context组件。</h4>

<p>Host确定以后，Mapper根据URL的路径来匹配相应的Web应用的路径，比如例子中访问的是/order，因此 找到了Context4 这个Context容器。</p>

<h4 id="4-最后-根据url路径找到wrapper-servlet">4. 最后，根据URL路径找到Wrapper(Servlet)。</h4>

<p>Context确定后，Mapper再根据web.xml中配置的Servlet映射路径来找到具体的Wrapper和Servlet。</p>

<p>看到这里，我想你应该已经了解了什么是容器，以及Tomcat如何通过一层一层的父子容器找到某个Servlet 来处理请求。需要注意的是，并不是说只有Servlet才会去处理请求，实际上这个查找路径上的父子容器都 会对请求做一些处理。我在上一期说过，连接器中的Adapter会调用容器的Service方法来执行Servlet，最先 拿到请求的是Engine容器，Engine容器对请求做一些处理后，会把请求传给自己子容器Host继续处理，依次类推，最后这个请求会传给Wrapper容器，Wrapper会调用最终的Servlet来处理。那么这个调用过程具体 是怎么实现的呢?答案是使用Pipeline-Valve管道。</p>

<h3 id="pipeline-valve管道">Pipeline-Valve管道</h3>

<p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。</p>

<blockquote>
<p><strong>ps: 关于责任链模式</strong>,在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p>

<p>在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；还有 Struts2 的拦截器、JSP 和 Servlet 的 Filter 等，所有这些，如果用责任链模式都能很好解决。</p>
</blockquote>

<p>Valve表示一个处理点，比如权限认证和记录日志。如果你还不太理解的话，可以来看看Valve和Pipeline接 口中的关键方法。</p>

<pre><code class="language-java">  public interface Valve {
    public Valve getNext();
    public void setNext(Valve valve);
    public void invoke(Request request, Response response)
}
</code></pre>

<p>由于Valve是一个处理点，因此invoke方法就是来处理请求的。注意到Valve中有getNext和setNext方法，因此我们大概可以猜到有一个链表将Valve链起来了。请你继续看Pipeline接口:</p>

<pre><code class="language-java">    public interface Pipeline extends Contained {
    public void addValve(Valve valve);
    public Valve getBasic();
    public void setBasic(Valve valve);
    public Valve getFirst();
  }
</code></pre>

<p>没错，Pipeline中有addValve方法。Pipeline中维护了Valve链表，Valve可以插入到Pipeline中，对请求做某 些处理。我们还发现Pipeline中没有invoke方法，因为整个调用链的触发是Valve来完成的，Valve完成自己 的处理后，调用getNext.invoke()来触发下一个Valve调用。</p>

<p>每一个容器都有一个Pipeline对象，只要触发这个Pipeline的第一个Valve，这个容器里Pipeline中的Valve就 都会被调用到。但是，不同容器的Pipeline是怎么链式触发的呢，比如Engine中Pipeline需要调用下层容器 Host中的Pipeline。</p>

<p>这是因为Pipeline中还有个getBasic方法。这个BasicValve处于Valve链表的末端，它是Pipeline中必不可少的 一个Valve，负责调用下层容器的Pipeline里的第一个Valve。我还是通过一张图来解释。</p>

<p><img src="/img/geektime-tomcat-pipeline-value.png" alt="img/geektime-tomcat-pipeline-value.png" />
整个调用过程由连接器中的Adapter触发的，它会调用Engine的第一个Valve:</p>

<pre><code class="language-java">// Calling the container 
connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
</code></pre>

<p>Wrapper容器的最后一个Valve会创建一个Filter链，并调用doFilter()方法，最终会调到Servlet的service方法。</p>

<p>你可能会问，前面我们不是讲到了Filter，似乎也有相似的功能，那Valve和Filter有什么区别吗?它们的区别是:</p>

<ul>
<li>Valve是Tomcat的私有机制，与Tomcat的基础架构/API是紧耦合的。Servlet API是公有的标准，所有的 Web容器包括Jetty都支持Filter机制。</li>
<li>另一个重要的区别是Valve工作在Web容器级别，拦截所有应用的请求;而Servlet Filter工作在应用级别， 只能拦截某个Web应用的所有请求。如果想做整个Web容器的拦截器，必须通过Valve来实现。</li>
</ul>

<h4 id="本期精华">本期精华</h4>

<p>今天我们学习了Tomcat容器的层次结构、根据请求定位Servlet的过程，以及请求在容器中的调用过程。 Tomcat设计了多层容器是为了灵活性的考虑，灵活性具体体现在一个Tomcat实例(Server)可以有多个 Service，每个Service通过多个连接器监听不同的端口，而一个Service又可以支持多个虚拟主机。一个URL 网址可以用不同的主机名、不同的端口和不同的路径来访问特定的Servlet实例。</p>

<p>请求的链式调用是基于Pipeline-Valve责任链来完成的，这样的设计使得系统具有良好的可扩展性，如果需 要扩展容器本身的功能，只需要增加相应的Valve即可。</p>

<h3 id="课后思考">课后思考</h3>

<p>Tomcat内的Context组件跟Servlet规范中的ServletContext接口有什么区别?跟Spring中的 ApplicationContext又有什么关系?
不知道今天的内容你消化得如何?如果还有疑问，请大胆的在留言区提问，也欢迎你把你的课后思考和心得
记录下来，与我和其他同学一起讨论。如果你觉得今天有所收获，欢迎你把它分享给你的朋友。</p>

<h3 id="精选留言">精选留言:</h3>

<ul>
<li><p>一路远行 2019-05-23 10:54:34</p>

<ul>
<li>1) Servlet规范中ServletContext表示web应用的上下文环境，而web应用对应tomcat的概念是Context， 所以从设计上，ServletContext自然会成为tomcat的Context具体实现的一个成员变量。</li>
<li>2) tomcat内部实现也是这样完成的，ServletContext对应tomcat实现是<code>org.apache.catalina.core.ApplicationContext</code>，Context容器对应tomcat实现是<code>org.apache.catalina.core.StandardContext</code>。ApplicationContext是StandardContext的一个成员变量。</li>
<li>3) Spring的ApplicationContext之前已经介绍过，tomcat启动过程中ContextLoaderListener会监听到容器初始化事件，它的contextInitialized方法中，Spring会初始化全局的Spring根容器ApplicationContext， 初始化完毕后，Spring将其存储到ServletContext中。
总而言之，Servlet规范中ServletContext是tomcat的Context实现的一个成员变量，而Spring的ApplicationContext是Servlet规范中ServletContext的一个属性。 [16赞]</li>
</ul></li>

<li><p>阿旺 2019-05-23 08:34:54</p>

<p>你好 请问到业务的controller是从哪部分进去的呢 谢谢 [3赞]</p>

<p>作者回复2019-05-23 09:27:21</p>

<p><code>Wrapper -&gt; Filter -&gt; DispatcherServlet -&gt; Controller</code></p></li>
</ul>
		</div>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="me avatar" src="/img/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About me</span>
	</div>
	<div class="authorbox__description">
		不动笔墨不读书
	</div>
</div>

<nav class="post-nav flex">
	<div class="post-nav__item post-nav__item--prev">
		<a class="post-nav__link" href="/post/geektime-tomcat-netty-02/" rel="prev"><span class="post-nav__caption">«&thinsp;Previous</span><p class="post-nav__post-title">Tomcat Netty-Tomcat系统架构(上): 连接器是如何设计的?</p></a>
	</div>
	<div class="post-nav__item post-nav__item--next">
		<a class="post-nav__link" href="/post/geektime-java-36-01/" rel="next"><span class="post-nav__caption">Next&thinsp;»</span><p class="post-nav__post-title">Java核心技术36讲-Java提供了哪些IO方式? NIO如何实现多路复用? </p></a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2019 quguang&#39;s blog.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/douban.js"></script></body>
</html>