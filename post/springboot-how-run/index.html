<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>SpringBoot 究竟是如何跑起来的? - Quguang 学习笔记</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="瞿广" /><meta name="description" content="不得不说 SpringBoot 太复杂了，我本来只想研究一下 SpringBoot 最简单的 HelloWorld 程序是如何从 main 方法一步一步跑起来的，但是这却是一个相当深的坑。你可以试着沿着调用栈代码一层一层的深入进去，如果你不打断点，你根本不知道接下来程序会往哪里流动。这个不同于我研究过去的 Go 语言、Python 语言框架，它们通常都非常直接了当，设计上清晰易懂，代码写起来简单，里面的实现同样也很简单。但是 SpringBoot 不是，它的外表轻巧简单，但是它的里面就像一只巨大的怪兽，这只怪兽有千百只脚把自己缠绕在一起，把爱研究源码的读者绕的晕头转向。
但是这 Java 编程的世界 SpringBoot 就是老大哥，你却不得不服。即使你的心中有千万头草泥马在奔跑，但是它就是天下第一。如果你是一个学院派的程序员，看到这种现象你会怀疑人生，你不得不接受一个规则 —— 受市场最欢迎的未必就是设计的最好的，里面夹杂着太多其它的非理性因素。
经过了一番痛苦的折磨，我还是把 SpringBoot 的运行原理摸清楚了，这里分享给大家。
" /><meta name="keywords" content="java, java语言, java语言笔记, techqu, quguang, 瞿广, 博客, 项目管理, python, 软件架构, 公众号, 小程序" />






<meta name="generator" content="Hugo 0.52 with even 4.0.0" />


<link rel="canonical" href="https://techqu.github.io/post/springboot-how-run/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/douban.css">
<link rel="stylesheet" href="/css/techqu.css">


<meta property="og:title" content="SpringBoot 究竟是如何跑起来的?" />
<meta property="og:description" content="不得不说 SpringBoot 太复杂了，我本来只想研究一下 SpringBoot 最简单的 HelloWorld 程序是如何从 main 方法一步一步跑起来的，但是这却是一个相当深的坑。你可以试着沿着调用栈代码一层一层的深入进去，如果你不打断点，你根本不知道接下来程序会往哪里流动。这个不同于我研究过去的 Go 语言、Python 语言框架，它们通常都非常直接了当，设计上清晰易懂，代码写起来简单，里面的实现同样也很简单。但是 SpringBoot 不是，它的外表轻巧简单，但是它的里面就像一只巨大的怪兽，这只怪兽有千百只脚把自己缠绕在一起，把爱研究源码的读者绕的晕头转向。

但是这 Java 编程的世界 SpringBoot 就是老大哥，你却不得不服。即使你的心中有千万头草泥马在奔跑，但是它就是天下第一。如果你是一个学院派的程序员，看到这种现象你会怀疑人生，你不得不接受一个规则 —— 受市场最欢迎的未必就是设计的最好的，里面夹杂着太多其它的非理性因素。

经过了一番痛苦的折磨，我还是把 SpringBoot 的运行原理摸清楚了，这里分享给大家。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://techqu.github.io/post/springboot-how-run/" /><meta property="article:published_time" content="2019-02-12T10:22:20&#43;08:00"/>
<meta property="article:modified_time" content="2019-02-12T10:22:20&#43;08:00"/>

<meta itemprop="name" content="SpringBoot 究竟是如何跑起来的?">
<meta itemprop="description" content="不得不说 SpringBoot 太复杂了，我本来只想研究一下 SpringBoot 最简单的 HelloWorld 程序是如何从 main 方法一步一步跑起来的，但是这却是一个相当深的坑。你可以试着沿着调用栈代码一层一层的深入进去，如果你不打断点，你根本不知道接下来程序会往哪里流动。这个不同于我研究过去的 Go 语言、Python 语言框架，它们通常都非常直接了当，设计上清晰易懂，代码写起来简单，里面的实现同样也很简单。但是 SpringBoot 不是，它的外表轻巧简单，但是它的里面就像一只巨大的怪兽，这只怪兽有千百只脚把自己缠绕在一起，把爱研究源码的读者绕的晕头转向。

但是这 Java 编程的世界 SpringBoot 就是老大哥，你却不得不服。即使你的心中有千万头草泥马在奔跑，但是它就是天下第一。如果你是一个学院派的程序员，看到这种现象你会怀疑人生，你不得不接受一个规则 —— 受市场最欢迎的未必就是设计的最好的，里面夹杂着太多其它的非理性因素。

经过了一番痛苦的折磨，我还是把 SpringBoot 的运行原理摸清楚了，这里分享给大家。">


<meta itemprop="datePublished" content="2019-02-12T10:22:20&#43;08:00" />
<meta itemprop="dateModified" content="2019-02-12T10:22:20&#43;08:00" />
<meta itemprop="wordCount" content="3233">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SpringBoot 究竟是如何跑起来的?"/>
<meta name="twitter:description" content="不得不说 SpringBoot 太复杂了，我本来只想研究一下 SpringBoot 最简单的 HelloWorld 程序是如何从 main 方法一步一步跑起来的，但是这却是一个相当深的坑。你可以试着沿着调用栈代码一层一层的深入进去，如果你不打断点，你根本不知道接下来程序会往哪里流动。这个不同于我研究过去的 Go 语言、Python 语言框架，它们通常都非常直接了当，设计上清晰易懂，代码写起来简单，里面的实现同样也很简单。但是 SpringBoot 不是，它的外表轻巧简单，但是它的里面就像一只巨大的怪兽，这只怪兽有千百只脚把自己缠绕在一起，把爱研究源码的读者绕的晕头转向。

但是这 Java 编程的世界 SpringBoot 就是老大哥，你却不得不服。即使你的心中有千万头草泥马在奔跑，但是它就是天下第一。如果你是一个学院派的程序员，看到这种现象你会怀疑人生，你不得不接受一个规则 —— 受市场最欢迎的未必就是设计的最好的，里面夹杂着太多其它的非理性因素。

经过了一番痛苦的折磨，我还是把 SpringBoot 的运行原理摸清楚了，这里分享给大家。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">专注</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">专注</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">SpringBoot 究竟是如何跑起来的?</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-02-12 </span>
        
          <span class="more-meta"> 约 3233 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#hello-world">Hello World</a>
<ul>
<li><a href="#项目目录">项目目录</a></li>
<li><a href="#pom文件">pom文件</a></li>
<li><a href="#java代码">java代码</a></li>
</ul></li>
<li><a href="#springboot-的堆栈">SpringBoot 的堆栈</a></li>
<li><a href="#探索-classloader">探索 ClassLoader</a></li>
<li><a href="#hellocontroller-自动注册">HelloController 自动注册</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>不得不说 SpringBoot 太复杂了，我本来只想研究一下 SpringBoot 最简单的 HelloWorld 程序是如何从 main 方法一步一步跑起来的，但是这却是一个相当深的坑。你可以试着沿着调用栈代码一层一层的深入进去，如果你不打断点，你根本不知道接下来程序会往哪里流动。这个不同于我研究过去的 Go 语言、Python 语言框架，它们通常都非常直接了当，设计上清晰易懂，代码写起来简单，里面的实现同样也很简单。但是 SpringBoot 不是，它的外表轻巧简单，但是它的里面就像一只巨大的怪兽，这只怪兽有千百只脚把自己缠绕在一起，把爱研究源码的读者绕的晕头转向。</p>

<p>但是这 Java 编程的世界 SpringBoot 就是老大哥，你却不得不服。即使你的心中有千万头草泥马在奔跑，但是它就是天下第一。如果你是一个学院派的程序员，看到这种现象你会怀疑人生，你不得不接受一个规则 —— 受市场最欢迎的未必就是设计的最好的，里面夹杂着太多其它的非理性因素。</p>

<p>经过了一番痛苦的折磨，我还是把 SpringBoot 的运行原理摸清楚了，这里分享给大家。</p>

<h2 id="hello-world">Hello World</h2>

<p>首先我们看看 SpringBoot 简单的 Hello World 代码，就两个文件 HelloControll.java 和 Application.java，运行 Application.java 就可以跑起来一个简单的 RESTFul Web 服务器了。</p>

<h3 id="项目目录">项目目录</h3>

<p><img src="/img/springboot-demo-project.png" alt="springboot-demo-project" /></p>

<h3 id="pom文件">pom文件</h3>

<p><img src="/img/springboot-demo-maven.jpg" alt="springboot-demo-maven" /></p>

<h3 id="java代码">java代码</h3>

<pre><code class="language-java">// HelloController.java
package hello;

import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestMapping;

@RestController
public class HelloController {

    @RequestMapping(&quot;/&quot;)
    public String index() {
        return &quot;Greetings from Spring Boot!&quot;;
    }

}

// Application.java
package hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
</code></pre>

<p>这时候访问 <code>http://localhost:8080</code> 就可以了</p>

<p>但是问题来了，在 Application 的 main 方法里我压根没有任何地方引用 HelloController 类，那么它的代码又是如何被服务器调用起来的呢？这就需要深入到 SpringApplication.run() 方法中看个究竟了。</p>

<p>不过即使不看代码，我们也很容易有这样的猜想，<strong>SpringBoot 肯定是在某个地方扫描了当前的 package，将带有 RestController 注解的类作为 MVC 层的 Controller 自动注册进了 Tomcat Server。</strong></p>

<p>还有一个让人不爽的地方是 SpringBoot 启动太慢了，一个简单的 Hello World 启动居然还需要长达 5 秒，要是再复杂一些的项目这样龟漫的启动速度那真是不好想象了。</p>

<p>再抱怨一下，这个简单的 HelloWorld 虽然 pom 里只配置了一个 maven 依赖，但是传递下去，它一共依赖了 36 个 jar 包，其中以 spring 开头的 jar 包有 15 个。说这是依赖地狱真一点不为过。</p>

<p><img src="/img/springboot-demo-maven-jars.jpg" alt="springboot-demo-maven-jars" /></p>

<h2 id="springboot-的堆栈">SpringBoot 的堆栈</h2>

<p>了解 SpringBoot 运行的最简单的方法就是看它的调用堆栈，下面这个启动调用堆栈还不是太深，我没什么可抱怨的。</p>

<p><img src="/img/springboot-demo-tomcatwebserver.jpg" alt="springboot-demo-tomcatwebserver" /></p>

<pre><code class="language-java">public class TomcatServer {

  @Override
  public void start() throws WebServerException {
  ...
  }

}
</code></pre>

<p>接下来再看看运行时堆栈，看看一个 HTTP 请求的调用栈有多深,绝大多数都是 Tomcat 的调用堆栈，跟 SpringBoot 相关的只有不到 10 层。</p>

<p><img src="/img/springboot-demo-helloController.jpg" alt="springboot-demo-helloController" /></p>

<h2 id="探索-classloader">探索 ClassLoader</h2>

<p>SpringBoot 还有一个特色的地方在于打包时它使用了 FatJar 技术将所有的依赖 jar 包一起放进了最终的 jar 包中的 BOOT-INF/lib 目录中，当前项目的 class 被统一放到了 BOOT-INF/classes 目录中。</p>

<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<p>这不同于我们平时经常使用的 maven shade 插件，将所有的依赖 jar 包中的 class 文件解包出来后再密密麻麻的塞进统一的 jar 包中。下面我们将 springboot 打包的 jar 包解压出来看看它的目录结构。</p>

<pre><code>├── BOOT-INF
│   ├── classes
│   │   └── hello
│   └── lib
│       ├── classmate-1.3.4.jar
│       ├── hibernate-validator-6.0.12.Final.jar
│       ├── jackson-annotations-2.9.0.jar
│       ├── jackson-core-2.9.6.jar
│       ├── jackson-databind-2.9.6.jar
│       ├── jackson-datatype-jdk8-2.9.6.jar
│       ├── jackson-datatype-jsr310-2.9.6.jar
│       ├── jackson-module-parameter-names-2.9.6.jar
│       ├── javax.annotation-api-1.3.2.jar
│       ├── jboss-logging-3.3.2.Final.jar
│       ├── jul-to-slf4j-1.7.25.jar
│       ├── log4j-api-2.10.0.jar
│       ├── log4j-to-slf4j-2.10.0.jar
│       ├── logback-classic-1.2.3.jar
│       ├── logback-core-1.2.3.jar
│       ├── slf4j-api-1.7.25.jar
│       ├── snakeyaml-1.19.jar
│       ├── spring-aop-5.0.9.RELEASE.jar
│       ├── spring-beans-5.0.9.RELEASE.jar
│       ├── spring-boot-2.0.5.RELEASE.jar
│       ├── spring-boot-autoconfigure-2.0.5.RELEASE.jar
│       ├── spring-boot-starter-2.0.5.RELEASE.jar
│       ├── spring-boot-starter-json-2.0.5.RELEASE.jar
│       ├── spring-boot-starter-logging-2.0.5.RELEASE.jar
│       ├── spring-boot-starter-tomcat-2.0.5.RELEASE.jar
│       ├── spring-boot-starter-web-2.0.5.RELEASE.jar
│       ├── spring-context-5.0.9.RELEASE.jar
│       ├── spring-core-5.0.9.RELEASE.jar
│       ├── spring-expression-5.0.9.RELEASE.jar
│       ├── spring-jcl-5.0.9.RELEASE.jar
│       ├── spring-web-5.0.9.RELEASE.jar
│       ├── spring-webmvc-5.0.9.RELEASE.jar
│       ├── tomcat-embed-core-8.5.34.jar
│       ├── tomcat-embed-el-8.5.34.jar
│       ├── tomcat-embed-websocket-8.5.34.jar
│       └── validation-api-2.0.1.Final.jar
├── META-INF
│   ├── MANIFEST.MF
│   └── maven
│       └── org.springframework
└── org
    └── springframework
        └── boot
</code></pre>

<p><strong>这种打包方式的优势在于最终的 jar 包结构很清晰，所有的依赖一目了然。</strong> 如果使用 maven shade 会将所有的 class 文件混乱堆积在一起，是无法看清其中的依赖。而最终生成的 jar 包在体积上两也者几乎是相等的。</p>

<p>在运行机制上，使用 FatJar 技术运行程序是需要对 jar 包进行改造的，它还需要自定义自己的 ClassLoader 来加载 jar 包里面 lib 目录中嵌套的 jar 包中的类。我们可以对比一下两者的 MANIFEST<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup> 文件就可以看出明显差异</p>

<pre><code>// Generated by Maven Shade Plugin
Manifest-Version: 1.0
Implementation-Title: gs-spring-boot
Implementation-Version: 0.1.0
Built-By: qianwp
Implementation-Vendor-Id: org.springframework
Created-By: Apache Maven 3.5.4
Build-Jdk: 1.8.0_191
Implementation-URL: https://projects.spring.io/spring-boot/#/spring-boot-starter-parent/gs-spring-boot
Main-Class: hello.Application

// Generated by SpringBootLoader Plugin
Manifest-Version: 1.0
Implementation-Title: gs-spring-boot
Implementation-Version: 0.1.0
Built-By: qianwp
Implementation-Vendor-Id: org.springframework
Spring-Boot-Version: 2.0.5.RELEASE
Main-Class: org.springframework.boot.loader.JarLauncher
Start-Class: hello.Application
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Created-By: Apache Maven 3.5.4
Build-Jdk: 1.8.0_191
Implementation-URL: https://projects.spring.io/spring-boot/#/spring-boot-starter-parent/gs-spring-boot
</code></pre>

<p>SpringBoot 将 jar 包中的 Main-Class 进行了替换，换成了 JarLauncher。还增加了一个 Start-Class 参数，这个参数对应的类才是真正的业务 main 方法入口。我们再看看这个 JarLaucher 具体干了什么</p>

<pre><code class="language-java"> public class JarLauncher{
    ...
  static void main(String[] args) {
    new JarLauncher().launch(args);
  }

  protected void launch(String[] args) {
    try {
      JarFile.registerUrlProtocolHandler();
      ClassLoader cl = createClassLoader(getClassPathArchives());
      launch(args, getMainClass(), cl);
    }
    catch (Exception ex) {
        ex.printStackTrace();
        System.exit(1);
    }
  }

  protected void launch(String[] args, String mcls, ClassLoader cl) {
        Runnable runner = createMainMethodRunner(mcls, args, cl);
        Thread runnerThread = new Thread(runner);
        runnerThread.setContextClassLoader(classLoader);
        runnerThread.setName(Thread.currentThread().getName());
        runnerThread.start();
  }

}

class MainMethodRunner {
  @Override
  public void run() {
    try {
      Thread th = Thread.currentThread();
      ClassLoader cl = th.getContextClassLoader();
      Class&lt;?&gt; mc = cl.loadClass(this.mainClassName);
      Method mm = mc.getDeclaredMethod(&quot;main&quot;, String[].class);
      if (mm == null) {
        throw new IllegalStateException(this.mainClassName
                        + &quot; does not have a main method&quot;);
      }
      mm.invoke(null, new Object[] { this.args });
    } catch (Exception ex) {
      ex.printStackTrace();
      System.exit(1);
    }
  }
}
</code></pre>

<p>从源码中可以看出 JarLaucher 创建了一个特殊的 ClassLoader，然后由这个 ClassLoader 来另启一个单独的线程来加载 MainClass 并运行。</p>

<p>又一个问题来了，当 JVM 遇到一个不认识的类，BOOT-INF/lib 目录里又有那么多 jar 包，它是如何知道去哪个 jar 包里加载呢？我们继续看这个特别的 ClassLoader 的源码</p>

<pre><code class="language-java">class LaunchedURLClassLoader extends URLClassLoader {
  ...
  private Class&lt;?&gt; doLoadClass(String name) {
    if (this.rootClassLoader != null) {
      return this.rootClassLoader.loadClass(name);
    }

    findPackage(name);
    Class&lt;?&gt; cls = findClass(name);
    return cls;
  }

}
</code></pre>

<p>这里的 rootClassLoader 就是双亲委派模型里的 ExtensionClassLoader ，JVM 内置的类会优先使用它来加载。如果不是内置的就去查找这个类对应的 Package。</p>

<pre><code class="language-java">private void findPackage(final String name) {
    int lastDot = name.lastIndexOf('.');
    if (lastDot != -1) {
        String packageName = name.substring(0, lastDot);
        if (getPackage(packageName) == null) {
            try {
                definePackage(name, packageName);
            } catch (Exception ex) {
                // Swallow and continue
            }
        }
    }
}

private final HashMap&lt;String, Package&gt; packages = new HashMap&lt;&gt;();

protected Package getPackage(String name) {
    Package pkg;
    synchronized (packages) {
        pkg = packages.get(name);
    }
    if (pkg == null) {
        if (parent != null) {
            pkg = parent.getPackage(name);
        } else {
            pkg = Package.getSystemPackage(name);
        }
        if (pkg != null) {
            synchronized (packages) {
                Package pkg2 = packages.get(name);
                if (pkg2 == null) {
                    packages.put(name, pkg);
                } else {
                    pkg = pkg2;
                }
            }
        }
    }
    return pkg;
}

private void definePackage(String name, String packageName) {
  String path = name.replace('.', '/').concat(&quot;.class&quot;);
  for (URL url : getURLs()) {
    try {
      if (url.getContent() instanceof JarFile) {
        JarFile jf= (JarFile) url.getContent();
        if (jf.getJarEntryData(path) != null &amp;&amp; jf.getManifest() != null) {
          definePackage(packageName, jf.getManifest(), url);
          return null;
        }
      }
    } catch (IOException ex) {
        // Ignore
    }
  }
  return null;
}
</code></pre>

<p>ClassLoader 会在本地缓存包名和 jar包路径的映射关系，如果缓存中找不到对应的包名，就必须去 jar 包中挨个遍历搜寻，这个就比较缓慢了。不过同一个包名只会搜寻一次，下一次就可以直接从缓存中得到对应的内嵌 jar 包路径。</p>

<p>深层 jar 包的内嵌 class 的 URL 路径长下面这样，使用感叹号 ! 分割</p>

<pre><code>jar:file:/workspace/springboot-demo/target/application.jar!/BOOT-INF/lib/snakeyaml-1.19.jar!/org/yaml/snakeyaml/Yaml.class
</code></pre>

<p>不过这个定制的 ClassLoader 只会用于打包运行时，在 IDE 开发环境中 main 方法还是直接使用系统类加载器加载运行的。</p>

<p>不得不说，SpringbootLoader 的设计还是很有意思的，它本身很轻量级，代码逻辑很独立没有其它依赖，它也是 SpringBoot 值得欣赏的点之一。</p>

<h2 id="hellocontroller-自动注册">HelloController 自动注册</h2>

<p>还剩下最后一个问题，那就是 HelloController 没有被代码引用，它是如何注册到 Tomcat 服务中去的？它靠的是注解传递机制。</p>

<p><img src="/img/spring-web-bind-annotation.jpg" alt="spring-web-bind-annotation" /></p>

<p>SpringBoot 深度依赖注解来完成配置的自动装配工作，它自己发明了几十个注解，确实严重增加了开发者的心智负担，你需要仔细阅读文档才能知道它是用来干嘛的。</p>

<p>Java 注解的形式和功能是分离的，它不同于 Python 的装饰器是功能性的，Java 的注解就好比代码注释，本身只有属性，没有逻辑，注解相应的功能由散落在其它地方的代码来完成，需要分析被注解的类结构才可以得到相应注解的属性。</p>

<p>那注解是又是如何传递的呢？</p>

<pre><code class="language-java">@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

@ComponentScan
public @interface SpringBootApplication {
...
}

public @interface ComponentScan {
    String[] basePackages() default {};
}
</code></pre>

<p>首先 main 方法可以看到的注解是 SpringBootApplication，这个注解又是由ComponentScan 注解来定义的，ComponentScan 注解会定义一个被扫描的包名称，如果没有显示定义那就是当前的包路径。SpringBoot 在遇到 ComponentScan 注解时会扫描对应包路径下面的所有 Class，根据这些 Class 上标注的其它注解继续进行后续处理。当它扫到 HelloController 类时发现它标注了 RestController 注解。</p>

<pre><code>@RestController
public class HelloController {
...
}

@Controller
public @interface RestController {
}
</code></pre>

<p>而 RestController 注解又标注了 Controller 注解。SpringBoot 对 Controller 注解进行了特殊处理，它会将 Controller 注解的类当成 URL 处理器注册到 Servlet 的请求处理器中，在创建 Tomcat Server 时，会将请求处理器传递进去。HelloController 就是如此被自动装配进 Tomcat 的。</p>

<p>扫描处理注解是一个非常繁琐肮脏的活计，特别是这种用注解来注解注解（绕口）的高级使用方法，这种方法要少用慎用。SpringBoot 中有大量的注解相关代码，企图理解这些代码是乏味无趣的没有必要的，它只会把你的本来清醒的脑袋搞晕。SpringBoot 对于习惯使用的同学来说它是非常方便的，但是其内部实现代码不要轻易模仿，那绝对算不上模范 Java 代码。</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">MANIFEST.MF：这个 manifest 文件定义了与扩展和包相关的数据。单词“manifest”的意思是“显示”,打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录，这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
</ol>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">瞿广</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-02-12
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/tomcat-overview/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Tomcat Overview</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/test-about/">
            <span class="next-text nav-default">《软件测试52讲》-谈谈测试</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/techqu" class="iconfont icon-github" title="github"></a>
  <a href="https://techqu.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">瞿广</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>






<script src="/js/douban.js"></script>


</body>
</html>
