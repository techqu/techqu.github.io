<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="Quguang&#39;s Blog">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://quguang.wang/img/bg-china.jpg">
    <meta property="twitter:image" content="https://quguang.wang/img/bg-china.jpg" />
    

    
    <meta name="title" content="《Java并发编程实战》-2-并发工具类(下)" />
    <meta property="og:title" content="《Java并发编程实战》-2-并发工具类(下)" />
    <meta property="twitter:title" content="《Java并发编程实战》-2-并发工具类(下)" />
    

    
    <meta name="description" content="瞿广，程序员, 开源爱好者，生活探险家 | 这里是 瞿广 的博客，与你一起发现更大的世界。">
    <meta property="og:description" content="瞿广，程序员, 开源爱好者，生活探险家 | 这里是 瞿广 的博客，与你一起发现更大的世界。" />
    <meta property="twitter:description" content="瞿广，程序员, 开源爱好者，生活探险家 | 这里是 瞿广 的博客，与你一起发现更大的世界。" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="瞿广, quguang, , 瞿广的网络日志, 瞿广的博客, quguang Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>《Java并发编程实战》-2-并发工具类(下)-瞿广的博客 | quguang Blog</title>

    <link rel="canonical" href="/post/geektime-java-concurrent-in-action.1.2/">

    <link rel="stylesheet" href="/css/iDisqus.min.css"/>
	
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    
    <link rel="stylesheet" href="/css/syntax.css">
    
    
    <link rel="stylesheet" href="/css/zanshang.css">
    
    
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    
    

    
    
    <script src="/js/jquery.min.js"></script>
    
    
    <script src="/js/bootstrap.min.js"></script>
    
    
    <script src="/js/hux-blog.min.js"></script>

    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/docco.min.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    

</head>



<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Quguang&#39;s Blog</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/categories/"></a>
                    </li>
                    
                    <li>
                        <a href="/categories/math">math</a>
                    </li>
                    
                    <li>
                        <a href="/categories/read">read</a>
                    </li>
                    
                    <li>
                        <a href="/categories/tech">tech</a>
                    </li>
                    
                    
		    
                        <li><a href="/top/books/">BOOKS</a></li>
                    
                        <li><a href="/top/about/">ABOUT</a></li>
                    

                    
		    <li>
                        <a href="/search">SEARCH <img src="/img/search.png" height="15" style="cursor: pointer;" alt="Search"></a>
		    </li>
                    
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/bg-china.jpg')
    }
</style>
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98" title="java并发实战">
                            java并发实战
                        </a>
                        
                    </div>
                    <h1>《Java并发编程实战》-2-并发工具类(下)</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by 
                        
                            瞿广
                         
                        on 
                        Friday, July 26, 2019
                        
                        
                        
                        <br>Last Modified on Saturday, July 27, 2019
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <header>
                    <h2>TOC</h2>
                </header>
                <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#21-原子类-无锁工具类的典范-重点学习">21|原子类：无锁工具类的典范(重点学习)</a>
<ul>
<li><a href="#无锁方案的实现原理">无锁方案的实现原理</a></li>
<li><a href="#看-java-如何实现原子化的-count-1">看 Java 如何实现原子化的 count += 1</a></li>
<li><a href="#原子类概览">原子类概览</a>
<ul>
<li><a href="#1-原子化的基本数据类型">1. 原子化的基本数据类型</a></li>
<li><a href="#2-原子化的对象引用类型">2. 原子化的对象引用类型</a></li>
<li><a href="#3-原子化数组">3. 原子化数组</a></li>
<li><a href="#4-原子化对象属性更新器">4. 原子化对象属性更新器</a></li>
<li><a href="#5-原子化的累加器">5. 原子化的累加器</a></li>
</ul></li>
<li><a href="#总结">总结</a></li>
</ul></li>
<li><a href="#22-executor与线程池-如何创建正确的线程池">22|Executor与线程池：如何创建正确的线程池？</a>
<ul>
<li><a href="#使用线程池要注意些什么">使用线程池要注意些什么</a></li>
</ul></li>
<li><a href="#23-future-如何用多线程实现最优的-烧水泡茶-程序">23|Future:如何用多线程实现最优的“烧水泡茶”程序？</a>
<ul>
<li><a href="#如何获取任务执行结果">如何获取任务执行结果</a></li>
<li><a href="#总结-1">总结</a></li>
</ul></li>
<li><a href="#24-completablefuture-异步编程没那么难">24|CompletableFuture：异步编程没那么难</a>
<ul>
<li><a href="#completablefuture的核心优势">CompletableFuture的核心优势</a></li>
<li><a href="#创建completablefuture对象">创建CompletableFuture对象</a></li>
</ul></li>
<li><a href="#25-completionservice-如何批量执行异步任务">25|CompletionService:如何批量执行异步任务</a></li>
<li><a href="#26-forkjoin-单机版的mapreduce">26|ForkJoin：单机版的MapReduce</a></li>
<li><a href="#27-并发工具类热点问题答疑">27|并发工具类热点问题答疑</a></li>
<li><a href="#总结-2">总结</a></li>
</ul></li>
</ul>
</nav>
                
                <p>前面我们多次提到一个累加器的例子，示例代码如下。在这个例子中，<code>add10K()</code>   这个方法不是线程安全的，问题就出在变量 count 的可见性和 <code>count+=1</code> 的原子性上。<strong>可见性问题可以用 volatile 来解决，而原子性问题我们前面一直都是采用的互斥锁方案。</strong></p>

<h2 id="21-原子类-无锁工具类的典范-重点学习">21|原子类：无锁工具类的典范(重点学习)</h2>

<pre><code class="language-java">public class Test{
  long count = 0;
  void add10k(){
    int idx = 0;
    while(idx++&lt;1000) {
      count +=1;
    }
  }
}
</code></pre>

<p><strong>其实对于简单的原子性问题，还有一种无锁方案。Java SDK 并发包将这种无锁方案封装提炼之 后，实现了一系列的原子类。</strong>不过，在深入介绍原子类的实现之前，我们先看看如何利用原子类 解决累加器问题，这样你会对原子类有个初步的认识。</p>

<p>在下面的代码中，我们将原来的 long 型变量 count 替换为了原子类 AtomicLong，原来的<code>count +=1</code>
替换成了<code>count.getAndIncrement()</code>，仅需要这两处简单的改动就能使 <code>add10K()</code>方法变成线程安 全的，原子类的使用还是挺简单的。</p>

<pre><code class="language-java">public class Test{
  AtomicLong count = new AtomicLong(0);
  void add10k(){
    int idx = 0;
    while(idx++&lt;1000) {
      count.getAndIncrement();
    }
  }
}
</code></pre>

<p>无锁方案相对互斥锁方案，最大的好处就是<strong>性能</strong>。互斥锁方案为了保证互斥性，需要执行加锁、 解锁操作，而加锁、解锁操作本身就消耗性能;同时拿不到锁的线程还会进入阻塞状态，进而触 发线程切换，线程切换对性能的消耗也很大。 相比之下，无锁方案则完全没有加锁、解锁的性能 消耗，同时还能保证互斥性，既解决了问题，又没有带来新的问题，可谓绝佳方案。那它是如何 做到的呢?</p>

<h3 id="无锁方案的实现原理">无锁方案的实现原理</h3>

<p>其实原子类性能高的秘密很简单，硬件支持而已。<strong>CPU 为了解决并发问题，提供了 CAS 指令</strong> (CAS，全称是 Compare And Swap，即“比较并交换”)。</p>

<p>CAS 指令包含 3 个参数:共享变量 的内存地址 A、用于比较的值 B 和共享变量的新值 C;并且只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。<strong>作为一条 CPU 指令，CAS 指令本身是能够保证原子性的。</strong></p>

<p>你可以通过下面 CAS 指令的模拟代码来理解 CAS 的工作原理。在下面的模拟程序中有两个参数， 一个是期望值 expect，另一个是需要写入的新值 newValue，<strong>只有当目前 count 的值和期望值 expect 相等时，才会将 count 更新为 newValue。</strong></p>

<pre><code class="language-java">class SimulatedCAS{
  int count;
  synchronized int cas(
  int expect, int newValue){
  // 读目前 count 的值
  int curValue = count;
  // 比较目前 count 值是否 == 期望值
  if(curValue == expect){
  // 如果是，则更新 count 的值
  count = newValue;
  }
  // 返回写入前的值
  return curValue;
  }
  }

</code></pre>

<p>你仔细地再次思考一下这句话，“只有当目前 count 的值和期望值 expect 相等时，才会将 count 更新为 newValue。”要怎么理解这句话呢?</p>

<p>对于前面提到的累加器的例子，<code>count += 1</code>
的一个核心问题是:基于内存中 count 的当前值 A 计算出来的<code>count+=1</code>为 A+1，在将 A+1 写入
内存的时候，很可能此时内存中 count 已经被其他线程更新过了，这样就会导致错误地覆盖其他 线程写入的值(如果你觉得理解起来还有困难，建议你再重新看看《01 | 可见性、原子性和有序 性问题:并发编程 Bug 的源头》)。也就是说，只有当内存中 count 的值等于期望值 A 时，才能 将内存中 count 的值更新为计算结果 A+1，这不就是 CAS 的语义吗</p>

<p>使用 CAS 来解决并发问题，一般都会伴随着自旋，而所谓自旋，其实就是循环尝试。例如，实现 一个线程安全的count += 1
操作，“CAS+ 自旋”的实现方案如下所示，首先计算 <code>newValue = count+1</code>，如果 <code>cas(count,newValue)</code> 返回的值不等于 count，则意味着线程在执行完代码1处之后，执行代码2 处之前，count 的值被其他线程更新过。那此时该怎么处理呢?可以采用自旋方案，就像下面代 码中展示的，可以重新读 count 最新的值来计算 newValue 并尝试再次更新，直到成功。</p>

<pre><code class="language-java">  class SimulatedCAS{ volatile int count; // 实现 count+=1 
  addOne(){

    do{
      newValue = count+1; //1
      }while(count != cas(count,newValue)//2 
    }

 // 模拟实现 CAS，仅用来帮助理解
 synchronized int cas(
 int expect, int newValue){
 // 读目前 count 的值
 int curValue = count;
 // 比较目前 count 值是否 == 期望值
 if(curValue == expect){
 // 如果是，则更新 count 的值
 count= newValue;
 }
 // 返回写入前的值
 return curValue;
 }
 }
</code></pre>

<p>通过上面的示例代码，想必你已经发现了，CAS 这种无锁方案，完全没有加锁、解锁操作，即便 两个线程完全同时执行 addOne() 方法，也不会有线程被阻塞，所以相对于互斥锁方案来说，性 能好了很多。
但是在 CAS 方案中，有一个问题可能会常被你忽略，那就是ABA的问题。什么是 ABA 问题呢?</p>

<p>前面我们提到“如果 cas(count,newValue) 返回的值不等于count，意味着线程在执行完代码1处 之后，执行代码2处之前，count 的值被其他线程更新过”，那如果 cas(count,newValue) 返回 的值等于count，是否就能够认为 count 的值没有被其他线程更新过呢?显然不是的，假设 count 原本是 A，线程 T1 在执行完代码1处之后，执行代码2处之前，有可能 <strong>count 被线程 T2 更新成 了 B，之后又被 T3 更新回了 A，</strong>这样线程 T1 虽然看到的一直是 A，但是其实已经被其他线程 <strong>更新过</strong>了，这就是 ABA 问题。</p>

<p>可能大多数情况下我们并不关心 ABA 问题，例如数值的原子递增，但也不能所有情况下都不关 心，例如 <strong>原子化的更新对象</strong>很可能就需要关心 ABA 问题，因为两个 A 虽然相等，但是第二个 A 的属性可能已经发生变化了。所以在使用 CAS 方案的时候，一定要先 check 一下。</p>

<h3 id="看-java-如何实现原子化的-count-1">看 Java 如何实现原子化的 count += 1</h3>

<p>在本文开始部分，我们使用原子类<code>AtomicLong的getAndIncrement()</code>方法替代了count += 1 ，从而实现了线程安全。原子类 AtomicLong 的<code>getAndIncrement()</code>方法内部就是基于 CAS 实现
的，下面我们来看看Java是如何使用CAS来实现原子化的count += 1的。</p>

<p>在 Java 1.8 版本中，<code>getAndIncrement()</code> 方法会转调 <code>unsafe.getAndAddLong()</code>方法。这里 <code>this</code> 和<code>valueOffset</code>两个参数可以唯一确定共享变量的内存地址。</p>

<pre><code class="language-java">final long getAndIncrement() { 
   return unsafe.getAndAddLong( this, valueOffset, 1L); 
     }
</code></pre>

<p><code>unsafe.getAndAddLong()</code> 方法的源码如下，该方法首先会在内存中读取共享变量的值，之后循环 调用 <code>compareAndSwapLong()</code> 方法来尝试设置共享变量的值，直到成功为止。 <code>compareAndSwapLong()</code>是一个 <code>native</code> 方法，只有当内存中共享变量的值等于 expected 时，才 会将共享变量的值更新为 x，并且返回 true;否则返回 fasle。<code>compareAndSwapLong</code> 的语义和 CAS 指令的语义的差别仅仅是返回值不同而已。</p>

<pre><code class="language-java">public final long getAndAddLong( Object o, long offset, long delta){ long v;
do{
// 读取内存中的值
    v = getLongVolatile(o, offset);
  } while (!compareAndSwapLong(
      o, offset, v, v + delta));
  return v;
}
// 原子性地将变量更新为 x
// 条件是内存中的值等于 expected
// 更新成功则返回 true
native boolean compareAndSwapLong( Object o, long offset, long expected, long x);
</code></pre>

<p>另外，需要你注意的是，<code>getAndAddLong()</code>方法的实现，基本上就是 CAS 使用的经典范例。所以 请你再次体会下面这段抽象后的代码片段，它在很多无锁程序中经常出现。Java 提供的原子类里 面 CAS 一般被实现为 <code>compareAndSet()</code>，<code>compareAndSet()</code> 的语义和 CAS 指令的语义的差别仅 仅是返回值不同而已，compareAndSet() 里面如果更新成功，则会返回 true，否则返回 false。</p>

<pre><code class="language-java">do {
// 获取当前值
oldV = xxxx;
// 根据当前值计算新值 newV = ...oldV...
}while(!compareAndSet(oldV,newV);
</code></pre>

<h3 id="原子类概览">原子类概览</h3>

<p>Java SDK 并发包里提供的原子类内容很丰富，我们可以将它们分为五个类别:原子化的基本数据 类型、原子化的对象引用类型、原子化数组、原子化对象属性更新器和原子化的累加器。这五个 类别提供的方法基本上是相似的，并且每个类别都有若干原子类，你可以通过下面的原子类组成 概览图来获得一个全局的印象。下面我们详细解读这五个类别。</p>

<h4 id="1-原子化的基本数据类型">1. 原子化的基本数据类型</h4>

<p>相关实现有 AtomicBoolean、AtomicInteger 和 AtomicLong，提供的方法主要有以下这些，详情 你可以参考 SDK 的源代码，都很简单，这里就不详细介绍了。</p>

<h4 id="2-原子化的对象引用类型">2. 原子化的对象引用类型</h4>

<p>相关实现有 AtomicReference、AtomicStampedReference 和 AtomicMarkableReference，利用 它们可以实现对象引用的原子化更新.不过需要注意的是，对象引用的更新需要重点关注 ABA 问题， AtomicStampedReference 和 AtomicMarkableReference 这两个原子类可以解决 ABA 问题</p>

<p>解决 ABA 问题的思路其实很简单，增加一个版本号维度就可以了，这个和我们在《18 | StampedLock:有没有比读写锁更快的锁?》介绍的乐观锁机制很类似，每次执行 CAS 操作，附加再更新一个版本号，只要保证版本号是递增的，那么即便 A 变成 B 之后再变回 A，版本号也不 会变回来(版本号递增的)</p>

<ul>
<li>AtomicStampedReference 实现的 CAS 方法就增加了版本号参数</li>
<li>AtomicMarkableReference 的实现机制则更简单，将版本号简化成了一个 Boolean</li>
</ul>

<h4 id="3-原子化数组">3. 原子化数组</h4>

<p>相关实现有 AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray，利用这些原子 类，我们可以原子化地更新数组里面的每一个元素。</p>

<h4 id="4-原子化对象属性更新器">4. 原子化对象属性更新器</h4>

<p>相关实现有 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater，利用它们可以原子化地更新对象的属性，这三个方法都是利用反 射机制实现的，创建更新器的方法如下:</p>

<pre><code class="language-java">public static &lt;U&gt;
 AtomicXXXFieldUpdater&lt;U&gt;
 newUpdater(Class&lt;U&gt; tclass,
 String fieldName)
</code></pre>

<h4 id="5-原子化的累加器">5. 原子化的累加器</h4>

<p>DoubleAccumulator、DoubleAdder、LongAccumulator 和 LongAdder，这四个类仅仅用来执行 累加操作，相比原子化的基本数据类型，速度更快，但是不支持 compareAndSet() 方法。如果你 仅仅需要累加操作，使用原子化的累加器性能会更好。</p>

<h3 id="总结">总结</h3>

<p>无锁方案相对于互斥锁方案，优点非常多，首先性能好，其次是基本不会出现死锁问题(但可能 出现饥饿和活锁问题，因为自旋会反复重试)。Java 提供的原子类大部分都实现了<code>compareAndSet()</code>方法，基于 <code>compareAndSet()</code>方法，你可以构建自己的无锁数据结构，但是建 议你不要这样做，这个工作最好还是让大师们去完成，原因是无锁算法没你想象的那么简单。</p>

<p>Java 提供的原子类能够解决一些简单的原子性问题，但你可能会发现，上面我们所有原子类的方法都是针对一个共享变量的，如果你需要解决多个变量的原子性问题，建议还是使用互斥锁方案。原子类虽好，但使用要慎之又慎。</p>

<h2 id="22-executor与线程池-如何创建正确的线程池">22|Executor与线程池：如何创建正确的线程池？</h2>

<p>虽然在Java语言中创建线程看上去就像创建一个对象一样简单，只需要new Thread()就可以了，但实际上创 建线程远不是创建一个对象那么简单。创建对象，仅仅是在JVM的堆里分配一块内存而已;而创建一个线 程，却需要调用操作系统内核的API，然后操作系统要为线程分配一系列的资源，这个成本就很高了，所以 线程是一个重量级的对象，应该避免频繁创建和销毁。</p>

<p>线程池的需求是如此普遍，所以Java SDK并发包自然也少不了它。但是很多人在初次接触并发包里线程池相 关的工具类时，多少会都有点蒙，不知道该从哪里入手，我觉得根本原因在于线程池和一般意义上的池化资 源是不同的。一般意义上的池化资源，都是下面这样，当你需要资源的时候就调用acquire()方法来申请资 源，用完之后就调用release()释放资源。若你带着这个固有模型来看并发包里线程池相关的工具类时，会很 遗憾地发现它们完全匹配不上，Java提供的线程池里面压根就没有申请线程和释放线程的方法。</p>

<pre><code class="language-java">class XXXPool{
// 获取池化资源 XXX acquire() { }
// 释放池化资源
void release(XXX x){ }
}
</code></pre>

<p>### 线程池是一种生产者-消费者模式
为什么线程池没有采用一般意义上池化资源的设计方法呢?如果线程池采用一般意义上池化资源的设计方 法，应该是下面示例代码这样。你可以来思考一下，假设我们获取到一个空闲线程T1，然后该如何使用T1 呢?你期望的可能是这样:通过调用T1的execute()方法，传入一个Runnable对象来执行具体业务逻辑，就 像通过构造函数Thread(Runnable target)创建线程一样。可惜的是，你翻遍Thread对象的所有方法，都不 存在类似<code>execute(Runnable target)</code>这样的公共方法。</p>

<p>线程池的使用方是生产者，线程池本身是消费者。 在下面的示例代码中，我们创建了一个非常简单的线程池MyThreadPool，你可以通过它来理解线程池的工 作原理。</p>

<pre><code class="language-java">//简化的线程池，仅用来说明工作原理 class MyThreadPool{
//利用阻塞队列实现生产者-消费者模式 BlockingQueue&lt;Runnable&gt; workQueue; //保存内部工作线程
List&lt;WorkerThread&gt; threads = new ArrayList&lt;&gt;();
// 构造方法 MyThreadPool(int poolSize,
BlockingQueue&lt;Runnable&gt; workQueue){ this.workQueue = workQueue;
// 创建工作线程
for(int idx=0; idx&lt;poolSize; idx++){
        WorkerThread work = new WorkerThread();
        work.start();
        threads.add(work);
} }
// 提交任务
void execute(Runnable command){
      workQueue.put(command);
    }
// 工作线程负责消费任务，并执行任务 class WorkerThread extends Thread{
public void run() { //循环取任务并执行 while(true){ 1
          Runnable task = workQueue.take();
          task.run();
        }
} }
}
/** 下面是使用示例 **/
// 创建有界阻塞队列 BlockingQueue&lt;Runnable&gt; workQueue =
new LinkedBlockingQueue&lt;&gt;(2);
// 创建线程池
MyThreadPool pool = new MyThreadPool(
10, workQueue); // 提交任务 pool.execute(()-&gt;{
      System.out.println(&quot;hello&quot;);
  });
</code></pre>

<p>在MyThreadPool的内部，我们维护了一个阻塞队列workQueue和一组工作线程，工作线程的个数由构造函 数中的poolSize来指定。用户通过调用execute()方法来提交Runnable任务，execute()方法的内部实现仅仅 是将任务加入到workQueue中。MyThreadPool内部维护的工作线程会消费workQueue中的任务并执行任 务，相关的代码就是代码1处的while循环。线程池主要的工作原理就这些，是不是还挺简单的?</p>

<p>Java并发包里提供的线程池，远比我们上面的示例代码强大得多，当然也复杂得多。Java提供的线程池相关 的工具类中，最核心的是ThreadPoolExecutor，通过名字你也能看出来，它强调的是Executor，而不是一般 意义上的池化资源。</p>

<p>ThreadPoolExecutor的构造函数非常复杂，如下面代码所示，这个最完备的构造函数有7个参数。</p>

<pre><code class="language-java">ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue&lt;Runnable&gt; workQueue,
    ThreadFactory threadFactory,
    RejectedExecutionHandler handler)
</code></pre>

<p>下面我们一一介绍这些参数的意义，你可以把线程池类比为一个项目组，而线程就是项目组的成员。</p>

<ul>
<li>corePoolSize:表示线程池保有的最小线程数。有些项目很闲，但是也不能把人都撤了，至少要留corePoolSize个人坚守阵地。</li>
<li>maximumPoolSize:表示线程池创建的最大线程数。当项目很忙时，就需要加人，但是也不能无限制地 加，最多就加到maximumPoolSize个人。当项目闲下来时，就要撤人了，最多能撤到corePoolSize个人。</li>
<li>keepAliveTime &amp; unit:上面提到项目根据忙闲来增减人员，那在编程世界里，如何定义忙和闲呢?很简 单，一个线程如果在一段时间内，都没有执行任务，说明很闲，keepAliveTime 和 unit 就是用来定义这 个“一段时间”的参数。也就是说，如果一个线程空闲了keepAliveTime &amp; unit这么久，而且线程池 的线程数大于 corePoolSize ，那么这个空闲的线程就要被回收了。</li>
<li>workQueue:工作队列，和上面示例代码的工作队列同义。</li>
<li>threadFactory:通过这个参数你可以自定义如何创建线程，例如你可以给线程指定一个有意义的名字。</li>
<li>handler:通过这个参数你可以自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队 列也满了(前提是工作队列是有界队列)，那么此时提交任务，线程池就会拒绝接收。至于拒绝的策略， 你可以通过handler这个参数来指定。</li>
</ul>

<p>ThreadPoolExecutor已经提供了以下4种策略。</p>

<ul>
<li>CallerRunsPolicy:提交任务的线程自己去执行该任务。</li>
<li>AbortPolicy:默认的拒绝策略，会throws RejectedExecutionException。</li>
<li>DiscardPolicy:直接丢弃任务，没有任何异常抛出。</li>
<li>DiscardOldestPolicy:丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入 到工作队列。</li>
</ul>

<p>Java在1.6版本还增加了 <code>allowCoreThreadTimeOut(boolean value)</code> 方法，它可以让所有线程都支持超时，这 意味着如果项目很闲，就会将项目组的成员都撤走。</p>

<h3 id="使用线程池要注意些什么">使用线程池要注意些什么</h3>

<p>考虑到ThreadPoolExecutor的构造函数实在是有些复杂，所以Java并发包里提供了一个线程池的静态工厂类</p>

<p>Executors，利用Executors你可以快速创建线程池。不过目前大厂的编码规范中基本上都不建议使用 Executors了，所以这里我就不再花篇幅介绍了。
不建议使用Executors的最重要的原因是:Executors提供的很多方法默认使用的都是无界的 LinkedBlockingQueue，高负载情境下，无界队列很容易导致OOM，而OOM会导致所有请求都无法处理， 这是致命问题。<strong>所以强烈建议使用有界队列。</strong></p>

<p>使用有界队列，当任务过多时，线程池会触发执行拒绝策略，线程池默认的拒绝策略会<code>throw RejectedExecutionException</code> 这是个运行时异常，对于运行时异常编译器并不强制catch它，所以开发人员 很容易忽略。因此默认拒绝策略要慎重使用。如果线程池处理的任务非常重要，建议自定义自己的拒绝策 略;并且在实际工作中，自定义的拒绝策略往往和降级策略配合使用。</p>

<p>使用线程池，还要注意异常处理的问题，例如通过ThreadPoolExecutor对象的execute()方法提交任务时， 如果任务在执行的过程中出现运行时异常，会导致执行任务的线程终止;不过，最致命的是任务虽然异常 了，但是你却获取不到任何通知，这会让你误以为任务都执行得很正常。虽然线程池提供了很多用于异常处 理的方法，但是最稳妥和简单的方案还是捕获所有异常并按需处理，你可以参考下面的示例代码。</p>

<pre><code class="language-java">try { //业务逻辑
} catch (RuntimeException x) { //按需处理
} catch (Throwable x) { //按需处理
}
</code></pre>

<h2 id="23-future-如何用多线程实现最优的-烧水泡茶-程序">23|Future:如何用多线程实现最优的“烧水泡茶”程序？</h2>

<h3 id="如何获取任务执行结果">如何获取任务执行结果</h3>

<p>Java通过ThreadPoolExecutor提供的3个submit()方法和1个FutureTask工具类来支持获得任务执行结果的需 求。下面我们先来介绍这3个submit()方法，这3个方法的方法签名如下。</p>

<pre><code class="language-java">// 提交Runnable任务
 Future&lt;?&gt; submit(Runnable task); 
 // 提交Callable任务
 
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); 

// 提交Runnable任务及结果引用
 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);
</code></pre>

<p>你会发现它们的返回值都是Future接口，Future接口有5个方法，我都列在下面了，它们分别是</p>

<ol>
<li>取消任务的 方法<code>cancel()</code></li>
<li>判断任务是否已取消的方法<code>isCancelled()</code></li>
<li>判断任务是否已结束的方法<code>isDone()</code></li>
<li>2个获得 任务执行结果的<code>get()</code>和<code>get(timeout, unit)</code>，其中最后一个<code>get(timeout, unit)</code>支持超时机制。</li>
</ol>

<p>通过Future接口 的这5个方法你会发现，我们提交的任务不但能够获取任务执行结果，还可以取消任务。不过需要注意的 是:这两个get()方法都是阻塞式的，如果被调用的时候，任务还没有执行完，那么调用get()方法的线程会阻 塞，直到任务执行完才会被唤醒。</p>

<p>这3个submit()方法之间的区别在于方法参数不同，下面我们简要介绍一下。
1. 提交Runnable任务 <code>submit(Runnable task)</code> :这个方法的参数是一个Runnable接口，Runnable接
口的run()方法是没有返回值的，所以<code>submit(Runnable task)</code>这个方法返回的Future<strong>仅可以用来断
言任务已经结束了</strong>，类似于<code>Thread.join()</code>。
2. 提交Callable任务 <code>submit(Callable&lt;T&gt; task)</code>:这个方法的参数是一个Callable接口，它只有一个call()方法，并且这个方法是有返回值的，所以这个方法返回的Future对象可以通过调用其get()方法来获取任务的执行结果。
3. 提交Runnable任务及结果引用 <code>submit(Runnable task, T result)</code>:这个方法很有意思，假设这
个方法返回的Future对象是f，f.get()的返回值就是传给submit()方法的参数result。这个方法该怎么用 呢?下面这段示例代码展示了它的经典用法。需要你注意的是Runnable接口的实现类Task声明了一个有 参构造函数<code>Task(Result r)</code>，创建Task对象的时候传入了result对象，这样就能在类Task的run()方法 中对result进行各种操作了。result相当于主线程和子线程之间的桥梁，通过它主子线程可以共享数据。</p>

<p>下面我们再来介绍FutureTask工具类。前面我们提到的Future是一个接口，而FutureTask是一个实实在在的 工具类，这个工具类有两个构造函数，它们的参数和前面介绍的submit()方法类似，所以这里我就不再赘述 了。</p>

<pre><code class="language-java">FutureTask(Callable&lt;V&gt; callable);
   FutureTask(Runnable runnable, V result);
</code></pre>

<p>那如何使用FutureTask呢?其实很简单，FutureTask实现了Runnable和Future接口，由于实现了Runnable 接口，所以可以将FutureTask对象作为任务提交给ThreadPoolExecutor去执行，也可以直接被Thread执 行;又因为实现了Future接口，所以也能用来获得任务的执行结果。下面的示例代码是将FutureTask对象提 交给ThreadPoolExecutor去执行。</p>

<pre><code class="language-java">// 创建FutureTask 
FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(()-&gt; 1+2); // 创建线程池
ExecutorService es = Executors.newCachedThreadPool();
 // 提交FutureTask 
 es.submit(futureTask);
// 获取计算结果
  Integer result = futureTask.get();
</code></pre>

<p>FutureTask对象直接被Thread执行的示例代码如下所示。相信你已经发现了，利用FutureTask对象可以很容 易获取子线程的执行结果。</p>

<pre><code class="language-java">// 创建FutureTask 
FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(()-&gt; 1+2);
// 创建并启动线程
Thread T1 = new Thread(futureTask); 
  T1.start();
// 获取计算结果
Integer result = futureTask.get();
</code></pre>

<h3 id="总结-1">总结</h3>

<p>利用Java并发包提供的Future可以很容易获得异步任务的执行结果，无论异步任务是通过线程池 ThreadPoolExecutor执行的，还是通过手工创建子线程来执行的。Future可以类比为现实世界里的提货单， 比如去蛋糕店订生日蛋糕，蛋糕店都是先给你一张提货单，你拿到提货单之后，没有必要一直在店里等着， 可以先去干点其他事，比如看场电影;等看完电影后，基本上蛋糕也做好了，然后你就可以凭提货单领蛋糕 了。</p>

<p>利用多线程可以快速将一些串行的任务并行化，从而提高性能;如果任务之间有依赖关系，比如当前任务依 赖前一个任务的执行结果，这种问题基本上都可以用Future来解决。在分析这种问题的过程中，建议你用有 向图描述一下任务之间的依赖关系，同时将线程的分工也做好，类似于烧水泡茶最优分工方案那幅图。对照 图来写代码，好处是更形象，且不易出错。</p>

<h2 id="24-completablefuture-异步编程没那么难">24|CompletableFuture：异步编程没那么难</h2>

<p>异步化，是并行方案得以实施的基础，更深入地讲其实就是:<strong>利用多线程优化性能这个核心方案得以实施的 基础</strong> 。看到这里，相信你应该就能理解异步编程最近几年为什么会大火了，因为优化性能是互联网大厂的一 个核心需求啊。Java在1.8版本提供了CompletableFuture来支持异步编程，CompletableFuture有可能是你 见过的最复杂的工具类了，不过功能也着实让人感到震撼。</p>

<h3 id="completablefuture的核心优势">CompletableFuture的核心优势</h3>

<p>为了领略CompletableFuture异步编程的优势，这里我们用CompletableFuture重新实现前面曾提及的烧水 泡茶程序。首先还是需要先完成分工方案，在下面的程序中，我们分了3个任务:任务1负责洗水壶、烧开 水，任务2负责洗茶壶、洗茶杯和拿茶叶，任务3负责泡茶。其中任务3要等待任务1和任务2都完成后才能开 始。这个分工如下图所示。</p>

<p><img src="/img/wash-cup-make-tea.png" alt="wash-cup-make-tea" /></p>

<p>下面是代码实现，你先略过 <code>runAsync()、supplyAsync()、thenCombine()</code>这些不太熟悉的方法，从大局上 看，你会发现:</p>

<ol>
<li>无需手工维护线程，没有繁琐的手工维护线程的工作，给任务分配线程的工作也不需要我们关注;</li>
<li>语义更清晰，例如 <code>f3 = f1.thenCombine(f2, ()-&gt;{})</code> 能够清晰地表述“任务3要等待任务1和任务2都完成后才能开始”;</li>

<li><p>代码更简练并且专注于业务逻辑，几乎所有代码都是业务逻辑相关的。</p>

<pre><code class="language-java">//任务1:洗水壶-&gt;烧开水 
CompletableFuture&lt;Void&gt; f1 = CompletableFuture.runAsync(()-&gt;{ 
System.out.println(&quot;T1:洗水壶...&quot;); 
sleep(1, TimeUnit.SECONDS);

System.out.println(&quot;T1:烧开水...&quot;);
 sleep(15, TimeUnit.SECONDS);
});

//任务2:洗茶壶-&gt;洗茶杯-&gt;拿茶叶 
CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(()-&gt;{ 
System.out.println(&quot;T2:洗茶壶...&quot;); 
sleep(1, TimeUnit.SECONDS);

System.out.println(&quot;T2:洗茶杯...&quot;);
sleep(2, TimeUnit.SECONDS);

System.out.println(&quot;T2:拿茶叶...&quot;); 
sleep(1, TimeUnit.SECONDS);
return &quot;⻰井&quot;;
}); 

//任务3:任务1和任务2完成后执行:泡茶 
CompletableFuture&lt;String&gt; f3 =f1.thenCombine(f2, (__, tf)-&gt;{ 
    
System.out.println(&quot;T1:拿到茶叶:&quot; + tf); 
System.out.println(&quot;T1:泡茶...&quot;);
 
return &quot;上茶:&quot; + tf; 
});

//等待任务3执行结果 
System.out.println(f3.join());
void sleep(int t, TimeUnit u) {
try {
  u.sleep(t);
}catch(InterruptedException e){}
}
// 一次执行结果: 
T1:洗水壶... 
T2:洗茶壶... 
T1:烧开水... 
T2:洗茶杯... 
T2:拿茶叶... 
T1:拿到茶叶:⻰井 
T1:泡茶... 
上茶:⻰井

</code></pre></li>
</ol>

<p>领略CompletableFuture异步编程的优势之后，下面我们详细介绍CompletableFuture的使用，首先是如何 创建CompletableFuture对象。</p>

<h3 id="创建completablefuture对象">创建CompletableFuture对象</h3>

<p>创建CompletableFuture对象主要靠下面代码中展示的这4个静态方法，我们先看前两个。在烧水泡茶的例 子中，我们已经使用了<code>runAsync(Runnable runnable)</code>和<code>supplyAsync(Supplier&lt;U&gt; supplier)</code>，它们之间的区别是:<strong>Runnable 接口的run()方法没有返回值，而Supplier接口的get()方法是有 返回值的。</strong></p>

<p>//TODO</p>

<p>前两个方法和后两个方法的区别在于:<strong>后两个方法可以指定线程池参数。</strong></p>

<h2 id="25-completionservice-如何批量执行异步任务">25|CompletionService:如何批量执行异步任务</h2>

<h2 id="26-forkjoin-单机版的mapreduce">26|ForkJoin：单机版的MapReduce</h2>

<p>前面几篇文章我们介绍了线程池、Future、CompletableFuture和CompletionService，仔细观察你会发现这些工具类都是在帮助我们<strong>站在任务的视角来解决并发问题</strong>，而不是让我们纠缠在线程之间如何协作的细节上 (比如线程之间如何实现等待、通知等)。</p>

<ul>
<li>对于简单的并行任务，你可以通过“线程池+Future”的方案来 解决;</li>
<li>如果任务之间有聚合关系，无论是AND聚合还是OR聚合，都可以通过CompletableFuture来解决;</li>
<li>而批量的并行任务，则可以通过CompletionService来解决。</li>
</ul>

<p>我们一直讲，并发编程可以分为三个层面的问题，分别是<strong>分工、协作和互斥</strong>，当你关注于任务的时候，你会发现你的视角已经从并发编程的细节中跳出来了，你应用的更多的是现实世界的思维模式，类比的往往是现实世界里的分工，所以我把线程池、Future、CompletableFuture和CompletionService都列到了分工里面。</p>

<p>上面提到的简单并行、聚合、批量并行这三种任务模型，基本上能够覆盖日常工作中的并发场景了，但还是 不够全面，因为还有一种“分治”的任务模型没有覆盖到。分治，顾名思义，即分而治之，是一种解决复杂 问题的思维方法和模式;具体来讲，指的是把一个复杂的问题分解成多个相似的子问题，然后再把子问题分 解成更小的子问题，直到子问题简单到可以直接求解。理论上来讲，解决每一个问题都对应着一个任务，所 以对于问题的分治，实际上就是对于任务的分治。</p>

<p>分治思想在很多领域都有广泛的应用，例如算法领域有分治算法(归并排序、快速排序都属于分治算法，二分法查找也是一种分治算法);大数据领域知名的计算框架MapReduce背后的思想也是分治。既然分治这 种任务模型如此普遍，那Java显然也需要支持，<strong>Java并发包里提供了一种叫做Fork/Join的并行计算框架，就 是用来支持分治这种任务模型的。</strong></p>

<h2 id="27-并发工具类热点问题答疑">27|并发工具类热点问题答疑</h2>

<ol>
<li>while(true) 总不让人省心</li>
<li>signalAll()总让人省心</li>
<li>Sempaphore需要锁中锁</li>
<li>锁的申请和释放要成对出现</li>
<li>回调总要关心执行线程是谁</li>
<li>共享线程池：有福同享就要有难同当</li>
<li>线上问题定位的利器：线程栈dump</li>
</ol>

<h2 id="总结-2">总结</h2>

<p>Java并发工具类到今天为止，就告一段落了，由于篇幅原因，不能每个工具类都详细介绍。Java并发工具类 内容繁杂，熟练使用是需要一个过程的，而且需要多加实践。希望你学完这个模块之后，<strong>遇到并发问题时最 起码能知道用哪些工具可以解决</strong>。至于工具使用的细节和最佳实践，我总结的也只是我认为重要的。由于每 个人的思维方式和编码习惯不同，也许我认为不重要的，恰恰是你的短板，所以这部分内容更多地还是需要 你去实践，在实践中养成良好的编码习惯，不断纠正错误的思维方式。</p>

                

                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/post/geektime-java-concurrent-in-action.1.1/" data-toggle="tooltip" data-placement="top" title="《Java并发编程实战》-2-并发工具类(上)">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/post/geektime-java-concurrent-in-action.2/" data-toggle="tooltip" data-placement="top" title="《Java并发编程实战》-3-并发设计模式（未完待续）">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>

                
<div id="disqus-comment"></div>



            </div>
            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        <a href="/tags/devops" title="devops">
                            devops
                        </a>
                        
                        
                        
                        <a href="/tags/docker" title="docker">
                            docker
                        </a>
                        
                        
                        
                        <a href="/tags/domain-driven-design" title="domain-driven-design">
                            domain-driven-design
                        </a>
                        
                        
                        
                        <a href="/tags/drools" title="drools">
                            drools
                        </a>
                        
                        
                        
                        <a href="/tags/dubbo" title="dubbo">
                            dubbo
                        </a>
                        
                        
                        
                        <a href="/tags/java" title="java">
                            java
                        </a>
                        
                        
                        
                        <a href="/tags/java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98" title="java并发实战">
                            java并发实战
                        </a>
                        
                        
                        
                        <a href="/tags/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98" title="java性能调优实战">
                            java性能调优实战
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/jvm" title="jvm">
                            jvm
                        </a>
                        
                        
                        
                        <a href="/tags/kubernetes" title="kubernetes">
                            kubernetes
                        </a>
                        
                        
                        
                        <a href="/tags/linux" title="linux">
                            linux
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/mq" title="mq">
                            mq
                        </a>
                        
                        
                        
                        <a href="/tags/mysql" title="mysql">
                            mysql
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/redis" title="redis">
                            redis
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/spring" title="spring">
                            spring
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E4%B9%A6%E5%8D%95" title="书单">
                            书单
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F" title="分布式">
                            分布式
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E5%AE%B9%E5%99%A8" title="容器">
                            容器
                        </a>
                        
                        
                        
                        <a href="/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8" title="工具使用">
                            工具使用
                        </a>
                        
                        
                        
                        <a href="/tags/%E5%B9%B6%E5%8F%91" title="并发">
                            并发
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" title="数据结构">
                            数据结构
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" title="消息队列">
                            消息队列
                        </a>
                        
                        
                        
                        <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%AB%98%E6%89%8B%E8%AF%BE" title="消息队列高手课">
                            消息队列高手课
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E7%AE%97%E6%B3%95" title="算法">
                            算法
                        </a>
                        
                        
                        
                        <a href="/tags/%E7%BC%93%E5%AD%98" title="缓存">
                            缓存
                        </a>
                        
                        
                        
                        <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE" title="网络协议">
                            网络协议
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA" title="虚拟机">
                            虚拟机
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE" title="趣谈网络协议">
                            趣谈网络协议
                        </a>
                        
                        
                        
                        <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E" title="软件工程之美">
                            软件工程之美
                        </a>
                        
                        
                        
                        <a href="/tags/%E9%80%8F%E8%A7%86http%E5%8D%8F%E8%AE%AE" title="透视http协议">
                            透视http协议
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E9%9D%A2%E8%AF%95" title="面试">
                            面试
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
                <section>
                    <hr>
                    <h5>FRIENDS</h5>
                    <ul class="list-inline">
                        
                        <li><a target="_blank" href="https://zhaozhihan.com">Linda的博客</a></li>
                        
                    </ul>
                </section>
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                   
                   <li>
                       <a href='' rel="alternate" type="application/rss+xml" title="Quguang&#39;s Blog" >
                           <span class="fa-stack fa-lg">
                               <i class="fa fa-circle fa-stack-2x"></i>
                               <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
                   
                    
                    <li>
                        <a href="mailto:youremail@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                    
                    
                    
                    

                    

		    
                    
                    <li>
                        <a target="_blank" href="/your%20wechat%20qr%20code%20image">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-wechat fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                    
                    <li>
                        <a target="_blank" href="https://github.com/yourgithub">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                    
                    
                    
                    <li>
                        <a target="_blank" href="https://www.linkedin.com/in/yourlinkedinid">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                    
                    
                    <li>
                        <a target="_blank" href="https://stackoverflow.com/users/yourstackoverflowid">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-stack-overflow fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
            
                    
                    
                    
                </ul>
		<p class="copyright text-muted">
                    Copyright &copy; Quguang&#39;s Blog 2019
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    async("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>






</body>
</html>
