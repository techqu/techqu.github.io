<!DOCTYPE html>
<!-- saved from url=(0049)http://localhost:1313/post/spring-design-pattern/ -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Spring是如何运用设计模式的？ - Quguang 学习笔记</title>
  <meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="瞿广"><meta name="description" content="关于设计模式，如果使用得当，将会使我们的代码更加简洁，并且更具扩展性。本文主要讲解Spring中如何使用策略模式，工厂方法模式以及Builder模式。
"><meta name="keywords" content="java, java语言, java语言笔记, techqu, quguang, 瞿广, 博客, 项目管理, python, 软件架构, 公众号, 小程序">






<meta name="generator" content="Hugo 0.52 with even 4.0.0">


<link rel="canonical" href="http://localhost:1313/post/spring-design-pattern/">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="manifest" href="http://localhost:1313/manifest.json">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg" color="#5bbad5">

<script async="" src="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/busuanzi.pure.mini.js"></script>
<link href="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/douban.css">
<link rel="stylesheet" href="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/techqu.css">


<meta property="og:title" content="Spring是如何运用设计模式的？">
<meta property="og:description" content="关于设计模式，如果使用得当，将会使我们的代码更加简洁，并且更具扩展性。本文主要讲解Spring中如何使用策略模式，工厂方法模式以及Builder模式。">
<meta property="og:type" content="article">
<meta property="og:url" content="http://localhost:1313/post/spring-design-pattern/"><meta property="article:published_time" content="2019-07-05T15:00:05+08:00">
<meta property="article:modified_time" content="2019-07-05T15:00:05+08:00">

<meta itemprop="name" content="Spring是如何运用设计模式的？">
<meta itemprop="description" content="关于设计模式，如果使用得当，将会使我们的代码更加简洁，并且更具扩展性。本文主要讲解Spring中如何使用策略模式，工厂方法模式以及Builder模式。">


<meta itemprop="datePublished" content="2019-07-05T15:00:05+08:00">
<meta itemprop="dateModified" content="2019-07-05T15:00:05+08:00">
<meta itemprop="wordCount" content="3873">



<meta itemprop="keywords" content="">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring是如何运用设计模式的？">
<meta name="twitter:description" content="关于设计模式，如果使用得当，将会使我们的代码更加简洁，并且更具扩展性。本文主要讲解Spring中如何使用策略模式，工厂方法模式以及Builder模式。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="http://localhost:1313/" class="logo">专注</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
  <ul class="mobile-menu-list">
    <a href="http://localhost:1313/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="http://localhost:1313/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="http://localhost:1313/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="http://localhost:1313/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="http://localhost:1313/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container slideout-panel slideout-panel-left" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="http://localhost:1313/" class="logo">专注</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="http://localhost:1313/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="http://localhost:1313/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="http://localhost:1313/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="http://localhost:1313/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="http://localhost:1313/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Spring是如何运用设计模式的？</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-07-05 </span>
        <div class="post-category">
            <a href="http://localhost:1313/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"> 设计模式 </a>
            <a href="http://localhost:1313/categories/spring/"> spring </a>
            </div>
          <span class="more-meta"> 约 3873 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta" style="display: inline;"> <span id="busuanzi_value_page_pv">50</span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="http://localhost:1313/post/spring-design-pattern/#1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" class=" toc-link">1. 策略模式</a></li>
<li><a href="http://localhost:1313/post/spring-design-pattern/#2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F" class=" toc-link">2. 工厂方法模式</a></li>
<li><a href="http://localhost:1313/post/spring-design-pattern/#3-builder%E6%A8%A1%E5%BC%8F" class=" toc-link">3. Builder模式</a></li>
<li><a href="http://localhost:1313/post/spring-design-pattern/#4-%E5%B0%8F%E7%BB%93" class=" toc-link">4. 小结</a></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>关于设计模式，如果使用得当，将会使我们的代码更加简洁，并且更具扩展性。本文主要讲解Spring中如何使用策略模式，工厂方法模式以及Builder模式。</p>

<h3 id="1-策略模式"><a href="http://localhost:1313/post/spring-design-pattern/#1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" class="headerlink anchor"><i class="iconfont icon-link"></i></a>1. 策略模式</h3>

<p>关于策略模式的使用方式，在Spring中其实比较简单，从本质上讲，策略模式就是一个接口下有多个实现类，而每种实现类会处理某一种情况。我们以发奖励为例进行讲解，比如我们在抽奖系统中，有多种奖励方式可供选择，比如积分，虚拟币和现金等。在存储时，我们必然会使用一个类似于type的字段用于表征这几种发放奖励的，那么这里我们就可以使用多态的方式进行奖励的发放。比如我们抽象出一个PrizeSender的接口，其声明如下：</p>

<figure class="language-java hljs highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PrizeSender</span> </span>{</div><div class="line"></div><div class="line">  <span class="hljs-comment">/**</span></div><div class="line">   * 用于判断当前实例是否支持当前奖励的发放</div><div class="line">   */</div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(SendPrizeRequest request)</span></span>;</div><div class="line"></div><div class="line">  <span class="hljs-comment">/**</span></div><div class="line">   * 发放奖励</div><div class="line">   */</div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendPrize</span><span class="hljs-params">(SendPrizeRequest request)</span></span>;</div><div class="line"></div><div class="line">}</div></pre></td></tr></tbody></table></figure>

<p>该接口中主要有两个方法：support()和sendPrize()，其中support()方法主要用于判断各个子类是否支持当前类型数据的处理，而sendPrize()则主要是用于进行具体的业务处理的，比如这里奖励的发放。下面就是我们三种不同类型的奖励发放的具体代码：</p>

<figure class="language-java hljs highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="hljs-comment">// 积分发放</span></div><div class="line"><span class="hljs-meta">@Component</span></div><div class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PrizeSender</span> </span>{</div><div class="line"></div><div class="line">  <span class="hljs-meta">@Override</span></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(SendPrizeRequest request)</span> </span>{</div><div class="line">    <span class="hljs-keyword">return</span> request.getPrizeType() == PrizeTypeEnum.POINT;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="hljs-meta">@Override</span></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendPrize</span><span class="hljs-params">(SendPrizeRequest request)</span> </span>{</div><div class="line">    System.out.println(<span class="hljs-string">"发放积分"</span>);</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="hljs-comment">// 虚拟币发放</span></div><div class="line"><span class="hljs-meta">@Component</span></div><div class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualCurrencySender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PrizeSender</span> </span>{</div><div class="line"></div><div class="line">  <span class="hljs-meta">@Override</span></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(SendPrizeRequest request)</span> </span>{</div><div class="line">    <span class="hljs-keyword">return</span> PrizeTypeEnum.VIRTUAL_CURRENCY == request.getPrizeType();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="hljs-meta">@Override</span></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendPrize</span><span class="hljs-params">(SendPrizeRequest request)</span> </span>{</div><div class="line">    System.out.println(<span class="hljs-string">"发放虚拟币"</span>);</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="hljs-comment">// 现金发放</span></div><div class="line"><span class="hljs-meta">@Component</span></div><div class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CashSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PrizeSender</span> </span>{</div><div class="line"></div><div class="line">  <span class="hljs-meta">@Override</span></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(SendPrizeRequest request)</span> </span>{</div><div class="line">    <span class="hljs-keyword">return</span> PrizeTypeEnum.CASH == request.getPrizeType();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="hljs-meta">@Override</span></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendPrize</span><span class="hljs-params">(SendPrizeRequest request)</span> </span>{</div><div class="line">    System.out.println(<span class="hljs-string">"发放现金"</span>);</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></tbody></table></figure>

<p>这里可以看到，在每种子类型中，我们只需要在support()方法中通过request的某个参数来控制当前request是否是当前实例能够处理的类型，如果是，则外层的控制逻辑就会将request交给当前实例进行处理。关于这个类的设计，有几个点需要注意：</p>

<p>使用<code>@Component</code>注解对当前类进行标注，将其声明为Spring容器所管理的一个bean；
声明一个返回boolean值的类似于<code>support()</code>的方法，通过这个方法来控制当前实例是否为处理目标request的实例；
声明一个类似于<code>sendPrize()</code>的方法用于处理业务逻辑，当然根据各个业务的不同声明的方法名肯定是不同的，这里只是一个对统一的业务处理的抽象；
无论是<code>support()</code>方法还是<code>sendPrize()</code>方法，都需要传一个对象进行，而不是简简单单的基本类型的变量，这样做的好处是 <strong>后续如果要在Request中新增字段，那么就不需要修改接口的定义和已经实现的各个子类的逻辑；</strong></p>

<h3 id="2-工厂方法模式"><a href="http://localhost:1313/post/spring-design-pattern/#2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F" class="headerlink anchor"><i class="iconfont icon-link"></i></a>2. 工厂方法模式</h3>

<p>上面我们讲解了如何使用Spring来声明一个策略模式，那么如何为不同的业务逻辑来注入不同的bean呢，或者说外层的控制逻辑是什么样的，这里我们就可以使用工厂方法模式了。所谓的工厂方法模式，就是定义一个工厂方法，通过传入的参数，返回某个实例，然后通过该实例来处理后续的业务逻辑。一般的，工厂方法的返回值类型是一个接口类型，而选择具体子类实例的逻辑则封装到了工厂方法中了。通过这种方式，来将外层调用逻辑与具体的子类的获取逻辑进行分离。如下图展示了工厂方法模式的一个示意图：</p>

<p>工厂方法模式</p>

<p>可以看到，工厂方法将具体实例的选择进行了封装，而客户端，也就是我们的调用方只需要调用工厂的具体方法获取到具体的事例即可，而不需要管具体的实例实现是什么。上面我们讲解了Spring中是如何使用策略模式声明处理逻辑的，而没有讲如何选择具体的策略，这里我们就可以使用工厂方法模式。如下是我们声明的一个PrizeSenderFactory：</p>

<figure class="language-java hljs highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="hljs-meta">@Component</span></div><div class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrizeSenderFactory</span> </span>{</div><div class="line"></div><div class="line">  <span class="hljs-meta">@Autowired</span></div><div class="line">  <span class="hljs-keyword">private</span> List&lt;PrizeSender&gt; prizeSenders;</div><div class="line"></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> PrizeSender <span class="hljs-title">getPrizeSender</span><span class="hljs-params">(SendPrizeRequest request)</span> </span>{</div><div class="line">    <span class="hljs-keyword">for</span> (PrizeSender prizeSender : prizeSenders) {</div><div class="line">      <span class="hljs-keyword">if</span> (prizeSender.support(request)) {</div><div class="line">        <span class="hljs-keyword">return</span> prizeSender;</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"unsupported request: "</span> + request);</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></tbody></table></figure>

<p>这里我们声明一个了一个工厂方法<code>getPrizeSender()</code>，其入参就是SendPrizeRequest，而返回值是某个实现了<code>PrizeSender</code>接口的实例，可以看到，通过这种方式，我们将具体的选择方式下移到了具体的子类中的，因为当前实现了<code>PrizeSender</code>的bean是否支持当前request的处理，是由具体的子类实现的。在该工厂方法中，我们也没有任何与具体子类相关的逻辑，也就是说，该类实际上是可以动态检测新加入的子类实例的。这主要是通过<code>Spring</code>的自动注入来实现的，主要是因为我们这里注入的是一个<code>List&lt;PrizeSender&gt;</code>，也就是说，如果有新的<code>PrizeSender</code>的子类实例，只要其是Spring所管理的，那么都会被注入到这里来。下面就是我们编写的一段用于测试的代码来模拟调用方的调用：</p>

<figure class="language-java hljs highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="hljs-meta">@Service</span></div><div class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationService</span> </span>{</div><div class="line"></div><div class="line">  <span class="hljs-meta">@Autowired</span></div><div class="line">  <span class="hljs-keyword">private</span> PrizeSenderFactory prizeSenderFactory;</div><div class="line"></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mockedClient</span><span class="hljs-params">()</span> </span>{</div><div class="line">    SendPrizeRequest request = <span class="hljs-keyword">new</span> SendPrizeRequest();</div><div class="line">    request.setPrizeType(PrizeTypeEnum.POINT);  <span class="hljs-comment">// 这里的request一般是根据数据库或外部调用来生成的</span></div><div class="line">    PrizeSender prizeSender = prizeSenderFactory.getPrizeSender(request);</div><div class="line">    prizeSender.sendPrize(request);</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></tbody></table></figure>

<p>在客户端代码中，首先通过<code>PrizeSenderFactory</code>获取一个PrizeSender实例，然后通过其<code>sendPrize()</code>方法发放具体的奖励，通过这种方式，将具体的奖励发放逻辑与客户端调用进行了解耦。而且根据前面的讲解，我们也知道，如果新增了一种奖励方式，我们只需要声明一个新的实现了PrizeSender的bean即可，而不需要对现有代码进行任何修改。</p>

<h3 id="3-builder模式"><a href="http://localhost:1313/post/spring-design-pattern/#3-builder%E6%A8%A1%E5%BC%8F" class="headerlink anchor"><i class="iconfont icon-link"></i></a>3. Builder模式</h3>

<p>关于Builder模式，我想使用过lombok的同学肯定会说builder模式非常的简单，只需要在某个bean上使用@Builder注解进行声明即可，lombok可以自动帮我们将其声明为一个Builder的bean。关于这种使用方式，本人不置可否，不过就我的理解，这里主要有两个点我们需要理解：</p>

<p>Builder模式就其名称而言，是一个构建者，我更倾向于将其理解为通过一定的参数，通过一定的业务逻辑来最终生成某个对象。如果仅仅只是使用lombok的这种方式，其本质上也还是创建了一个简单的bean，这个与通过getter和setter方式构建一个bean是没有什么大的区别的；
在Spring框架中，使用设计模式最大的问题在于如果在各个模式bean中能够注入Spring的bean，如果能够注入，那么将大大的扩展其使用方式。因为我们就可以真的实现通过传入的简单的几个参数，然后结合Spring注入的bean进行一定的处理后，以构造出我们所需要的某个bean。显然，这是lombok所无法实现的；</p>

<p>关于Builder模式，我们可以以前面奖励发放的SendPrizeRequest的构造为例进行讲解。在构造request对象的时候，必然是通过前台传如的某些参数来经过一定的处理，最后生成一个request对象。那么我们就可以使用Builder模式来构建一个SendPrizeRequest。这里假设根据前台调用，我们能够获取到prizeId和userId，那么我们就可以创建一个如下的SendPrizeRequest：</p>

<figure class="language-java hljs highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendPrizeRequest</span> </span>{</div><div class="line"></div><div class="line">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PrizeTypeEnum prizeType;</div><div class="line">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> amount;</div><div class="line">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String userId;</div><div class="line"></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SendPrizeRequest</span><span class="hljs-params">(PrizeTypeEnum prizeType, <span class="hljs-keyword">int</span> amount, String userId)</span> </span>{</div><div class="line">    <span class="hljs-keyword">this</span>.prizeType = prizeType;</div><div class="line">    <span class="hljs-keyword">this</span>.amount = amount;</div><div class="line">    <span class="hljs-keyword">this</span>.userId = userId;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="hljs-meta">@Component</span></div><div class="line">  <span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)</div><div class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>{</div><div class="line"></div><div class="line">    <span class="hljs-meta">@Autowired</span></div><div class="line">    PrizeService prizeService;</div><div class="line"></div><div class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> prizeId;</div><div class="line">    <span class="hljs-keyword">private</span> String userId;</div><div class="line"></div><div class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">prizeId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prizeId)</span> </span>{</div><div class="line">      <span class="hljs-keyword">this</span>.prizeId = prizeId;</div><div class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">userId</span><span class="hljs-params">(String userId)</span> </span>{</div><div class="line">      <span class="hljs-keyword">this</span>.userId = userId;</div><div class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> SendPrizeRequest <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>{</div><div class="line">      Prize prize = prizeService.findById(prizeId);</div><div class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SendPrizeRequest(prize.getPrizeType(), prize.getAmount(), userId);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> PrizeTypeEnum <span class="hljs-title">getPrizeType</span><span class="hljs-params">()</span> </span>{</div><div class="line">    <span class="hljs-keyword">return</span> prizeType;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAmount</span><span class="hljs-params">()</span> </span>{</div><div class="line">    <span class="hljs-keyword">return</span> amount;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserId</span><span class="hljs-params">()</span> </span>{</div><div class="line">    <span class="hljs-keyword">return</span> userId;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></tbody></table></figure>

<p>这里就是使用Spring维护一个Builder模式的示例，具体的 维护方式就是在Builder类上使用<code>@Component</code>和<code>@Scope</code>注解来标注该Builder类，这样我们就可以在Builder类中注入我们所需要的实例来进行一定的业务处理了。关于该模式，这里有几点需要说明：</p>

<p>在Builder类上必须使用<code>@Scope</code>注解来标注该实例为<code>prototype</code>类型，因为很明显，我们这里的Builder实例是有状态的，无法被多线程共享；
在<code>Builder.build()</code>方法中，我们可以通过传入的参数和注入的bean来进行一定的业务处理，从而得到构建一个SendPrizeRequest所需要的参数；
Builder类必须使用static修饰，因为在Java中，如果内部类不用static修饰，那么该类的实例必须依赖于外部类的一个实例，而我们这里本质上是希望通过内部类实例来构建外部类实例，也就是说内部类实例存在的时候，外部类实例是还不存在的，因而这里必须使用static修饰；
根据标准的Builder模式的使用方式，外部类的各个参数都必须使用final修饰，然后只需要为其声明getter方法即可。
       上面我们展示了如何使用Spring的方式来声明一个Builder模式的类，那么我们该如何进行使用呢，如下是我们的一个使用示例：</p>

<p>```java</p>

<p>@Service
public class ApplicationService {</p>

<p>@Autowired
  private PrizeSenderFactory prizeSenderFactory;</p>

<p>@Autowired
  private ApplicationContext context;</p>

<p>public void mockedClient() {
    SendPrizeRequest request = newPrizeSendRequestBuilder()
        .prizeId(1)
        .userId(“u4352234”)
        .build();</p>

<figure class="hljs highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PrizeSender prizeSender = prizeSenderFactory.getPrizeSender(request);</div><div class="line">prizeSender.sendPrize(request);</div></pre></td></tr></tbody></table></figure>

<p>}</p>

<p>public Builder newPrizeSendRequestBuilder() {
    return context.getBean(Builder.class);
  }
}```</p>

<p>上述代码中，我们主要要看一下newPrizeSendRequestBuilder()方法，在Spring中，如果一个类是多例类型，也即使用@Scope(“prototype”)进行了标注，那么每次获取该bean的时候就必须使用ApplicationContext.getBean()方法获取一个新的实例，至于具体的原因，读者可查阅相关文档。我们这里就是通过一个单独的方法来创建一个Builder对象，然后通过流式来为其设置prizeId和userId等参数，最后通过build()方法构建得到了一个SendPrizeRequest实例，通过该实例来进行后续的奖励发放。</p>

<h3 id="4-小结"><a href="http://localhost:1313/post/spring-design-pattern/#4-%E5%B0%8F%E7%BB%93" class="headerlink anchor"><i class="iconfont icon-link"></i></a>4. 小结</h3>

<p>本文主要通过一个奖励发放的示例来对Spring中如何使用工厂方法模式，策略模式和Builder模式的方式进行讲解，并且着重强调了实现各个模式时我们所需要注意的点。</p>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">瞿广</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-07-05
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="http://localhost:1313/post/2018-2019/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">2018总结-2019展望</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="http://localhost:1313/post/springboot-prevent-repeat-submit/">
            <span class="next-text nav-default">Spring Boot 使用 AOP 防止重复提交</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/techqu" class="iconfont icon-github" title="github"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io/">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv" style="display: inline;"> 本站总访问量 <span id="busuanzi_value_site_pv">11885508</span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv" style="display: inline;"> 本站总访客数 <span id="busuanzi_value_site_uv">725793</span> 人 </span>
  </div>

  <span class="copyright-year">
    © 
    2018 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">瞿广</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/highlight.pack.js"></script>
  <script src="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/even.26188efa.min.js"></script>






<script src="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/douban.js"></script>


<script data-no-instant="">document.write('<script src="/livereload.js?port=1313&mindelay=10"></' + 'script>')</script><script src="./Spring是如何运用设计模式的？ - Quguang 学习笔记_files/livereload.js"></script>

</body></html>